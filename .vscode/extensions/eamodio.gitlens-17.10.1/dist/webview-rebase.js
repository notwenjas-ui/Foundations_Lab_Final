exports.id=653,exports.ids=[653],exports.modules={6673(e,t,i){i.d(t,{RebaseWebviewProvider:()=>RebaseWebviewProvider,q:()=>ea});var s=i(1398),n=i(7529),o=i(2441),r=i(2531),a=i(751),c=i(6742),h=i(7996),l=e=>{throw TypeError(e)};let d=new Map([["p","pick"],["pick","pick"],["r","reword"],["reword","reword"],["e","edit"],["edit","edit"],["s","squash"],["squash","squash"],["f","fixup"],["fixup","fixup"],["d","drop"],["drop","drop"],["b","break"],["break","break"],["x","exec"],["exec","exec"],["l","label"],["label","label"],["t","reset"],["reset","reset"],["m","merge"],["merge","merge"],["u","update-ref"],["update-ref","update-ref"],["noop","noop"]]),u=/^\s?#\s?Rebase\s([0-9a-f]+)(?:\.\.([0-9a-f]+))?\sonto\s([0-9a-f]+)\s.*$/im,m=/^(p|pick|r|reword|e|edit|s|squash|f|fixup|d|drop|b|break|x|exec|l|label|t|reset|m|merge|u|update-ref|noop)(?:\s+(?:(-[Cc])\s+)?([0-9a-f]+|\S+))?(?:\s+(?:#\s*)?(.*))?$/;function p(e){var t,i,s,n,o,r=[];try{let t,i=((e,t)=>{if(null!=t){var i,s;let n,o;"object"!=typeof t&&"function"!=typeof t&&l("Object expected"),void 0===i&&(i=t[n="dispose",(o=Symbol[n])?o:Symbol.for("Symbol."+n)]),"function"!=typeof i&&l("Object not disposable"),s&&(i=function(){try{s.call(this)}catch(e){return Promise.reject(e)}}),e.push([void 0,i,t])}return t})(r,(0,c.u)("Git.parseRebaseTodo",{log:!1,logLevel:"debug"}));if(!e)return i?.stop({suffix:" no data"}),{entries:[]};let s=u.exec(e);if(s){let[,e,i,n]=s;t={from:e||void 0,to:i||void 0,onto:n}}let n=[],o=-1;for(let t of(0,h.HX)(e,`
`)){let e;if(o++,!(t=t.trim())||t.startsWith("#"))continue;let i=m.exec(t);if(!i)continue;let[,s,r,a,c]=i,h=d.get(s);if(h){switch(h){case"pick":case"reword":case"edit":case"squash":case"drop":e={line:o,action:h,sha:a,message:c||""};break;case"fixup":e=r?{line:o,action:h,sha:a,message:c||"",flag:r}:{line:o,action:h,sha:a,message:c||""};break;case"break":case"noop":e={line:o,action:h};break;case"exec":{let i=t.startsWith("x ")?2:5;e={line:o,action:h,command:t.slice(i)};break}case"label":case"reset":case"update-ref":e={line:o,action:h,ref:a};break;case"merge":if(r&&a&&c){let t=c.split(/\s*#\s*/);e={line:o,action:h,sha:a,ref:t[0],message:t[1],flag:r}}else{if(!a)continue;let t=a.split(/\s*#\s*/);e={line:o,action:h,ref:t[0],message:t[1]}}break;default:continue}n.push(e)}}return i?.stop({suffix:` parsed ${n.length} entries`}),{entries:n,info:t}}catch(e){var a=e,p=!0}finally{t=a,i=p,s="function"==typeof SuppressedError?SuppressedError:function(e,t,i,s){return(s=Error(i)).name="SuppressedError",s.error=e,s.suppressed=t,s},n=e=>t=i?new s(e,t,"An error was suppressed during disposal"):(i=!0,e),(o=e=>{for(;e=r.pop();)try{var s=e[1]&&e[1].call(e[2]);if(e[0])return Promise.resolve(s).then(o,e=>(n(e),o()))}catch(e){n(e)}if(i)throw t})()}}let f=new Set(["pick","reword","edit","squash","fixup","drop"]),g=new Set(["exec","break","noop"]);function v(e,t){let i=t??e.action;if("commit"===e.type){let t=e.flag?` ${e.flag}`:"";return`${i}${t} ${e.sha} ${e.message}`}return"exec"===e.action?`exec${e.command?` ${e.command}`:""}`:e.action}function w(e){return`update-ref ${e}`}function b(e,t){let i,s=e.some(e=>"merge"===e.action),n=[],o=new Map;for(let s of e)if("label"!==s.action&&"reset"!==s.action){if(null!=s.sha&&null!=s.message&&f.has(s.action)){let e={...s,type:"commit",id:s.sha,done:t};n.push(e),o.set(e.sha,e),i=e;continue}if("update-ref"===s.action&&null!=s.ref){i&&(i.updateRefs??=[],i.updateRefs.push({ref:s.ref,line:s.line}));continue}if(g.has(s.action)){n.push({...s,type:"command",id:`${t?"done:":""}line:${s.line}`,done:t});continue}}return{entries:n,commits:o,preservesMerges:s}}async function y(e){try{let t=s.Uri.joinPath(e,"..","done"),i=new TextDecoder().decode(await s.workspace.fs.readFile(t));if(!i.trim())return;return{entries:p(i).entries}}catch{return}}var R=i(6418),E=i(8256),S=i(6611),C=i(4713),_=i(4170),P=i(7247),D=i(5916),x=i(4257),k=i(8986),T=i(6607),W=i(7775),M=i(1396),$=i(5162),I=i(2126);let A="rebase",O=new I.Q2(A,"abort"),j=new I.Q2(A,"continue"),Q=new I.Q2(A,"search"),q=new I.Q2(A,"skip"),U=new I.Q2(A,"start"),B=new I.Q2(A,"switch"),F=new I.Q2(A,"reorder"),G=new I.Q2(A,"change/entry"),H=new I.Q2(A,"change/entries"),L=new I.Q2(A,"move/entry"),V=new I.Q2(A,"move/entries"),z=new I.Q2(A,"shift/entries"),N=new I.Q2(A,"selection/update"),Z=new I.Q2(A,"revealRef"),X=new I.Q2(A,"avatars/get"),Y=new I.Q2(A,"commits/get"),J=new I.Q2(A,"recompose/open"),K=new I.Oz(A,"conflicts/get"),ee=new I.C1(A,"didChange"),et=new I.C1(A,"avatars/didChange"),ei=new I.C1(A,"commits/didChange"),es=new I.C1(A,"subscription/didChange");let RebaseTodoDocument=class RebaseTodoDocument{constructor(e){this.document=e}_parsedCache;get parsed(){if(this._parsedCache?.version===this.document.version)return this._parsedCache;let e=p(this.document.getText()),t=b(e.entries);return this._parsedCache={version:this.document.version,parsed:e,processed:t},this._parsedCache}get uri(){return this.document.uri}calculateMoveTargetIndex(e,t,i){if(e.relative){let s=t+e.to;return s<0||s>=i?null:s}return t===e.to?null:e.to}async changeActions(e){if(!e.length)return;let{commits:t}=this.parsed.processed,i=new s.WorkspaceEdit,n=new Map(e.map(e=>[e.sha,e.action])),[o]=(0,W.Tj)(t.values(),e=>{let t=n.get(e.sha);return null!=t?{...e,action:t}:e});if(!o)return;let r="squash"===o.action||"fixup"===o.action;for(let{sha:n,action:a}of e){let e=t.get(n);if(null==e)continue;let c=a;r&&n===o.sha&&(c="pick");let h=this.document.validateRange(new s.Range(new s.Position(e.line,0),new s.Position(e.line,ea))),l=e.flag?` ${e.flag}`:"";i.replace(this.document.uri,h,`${c}${l} ${e.sha} ${e.message}`)}if(r&&!n.has(o.sha)){let e=t.get(o.sha);if(null!=e){let t=this.document.validateRange(new s.Range(new s.Position(e.line,0),new s.Position(e.line,ea))),n=e.flag?` ${e.flag}`:"";i.replace(this.document.uri,t,`pick${n} ${e.sha} ${e.message}`)}}await s.workspace.applyEdit(i)}async clear(){let e=new s.WorkspaceEdit;e.delete(this.document.uri,new s.Range(0,0,this.document.lineCount,0)),await s.workspace.applyEdit(e)}async ensureValidOldestAction(e){if("squash"!==e.action&&"fixup"!==e.action)return;let t=this.document.validateRange(new s.Range(new s.Position(e.line,0),new s.Position(e.line,ea))),i=new s.WorkspaceEdit;i.replace(this.document.uri,t,`pick ${e.sha} ${e.message}`),await s.workspace.applyEdit(i)}async moveEntry(e,t,i,n){let o=new s.WorkspaceEdit,r=[v(e)];if("commit"===e.type&&e.updateRefs?.length)for(let t of e.updateRefs)r.push(w(t.ref));let a=`${r.join(`
`)}
`,c=e.line+1;"commit"===e.type&&e.updateRefs?.length&&(c=Math.max(...e.updateRefs.map(e=>e.line))+1);let h=this.document.validateRange(new s.Range(new s.Position(e.line,0),new s.Position(c,0))),l=t.line+1;if("commit"===t.type&&t.updateRefs?.length&&(l=Math.max(...t.updateRefs.map(e=>e.line))+1),e.line<t.line){let e=i||n?l:t.line;o.insert(this.document.uri,new s.Position(e,0),a),o.delete(this.document.uri,h)}else o.delete(this.document.uri,h),o.insert(this.document.uri,new s.Position(t.line,0),a);await s.workspace.applyEdit(o)}async reorderEntries(e,t){let i=new Set;for(let e of this.parsed.processed.entries)if(i.add(e.line),"commit"===e.type&&e.updateRefs?.length)for(let t of e.updateRefs)i.add(t.line);let n=[...i].sort((e,t)=>e-t);if(0===n.length)return;let o=n[0],r=n[n.length-1],a=[];for(let i of e){let e=i.id===t?.id?"pick":void 0;if(a.push(v(i,e)),"commit"===i.type&&i.updateRefs?.length)for(let e of i.updateRefs)a.push(w(e.ref))}let c=new s.WorkspaceEdit,h=this.document.validateRange(new s.Range(new s.Position(o,0),new s.Position(r,ea)));c.replace(this.document.uri,h,a.join(`
`)),await s.workspace.applyEdit(c)}async save(){return this.document.save()}wouldLeaveSquashAsOldest(e,t,i){let s=e[t],n=[...e];n.splice(t,1),n.splice(i,0,s);let o=n.find(e=>"commit"===e.type);return!!o&&("squash"===o.action||"fixup"===o.action)}};var en=Object.defineProperty,eo=Object.getOwnPropertyDescriptor,er=(e,t,i,s)=>{for(var n,o=s>1?void 0:s?eo(t,i):t,r=e.length-1;r>=0;r--)(n=e[r])&&(o=(s?n(t,i,o):n(o))||o);return s&&o&&en(t,i,o),o};let ea=0x40000000-1,{command:ec,getCommands:eh}=(0,x.V)();let RebaseWebviewProvider=class RebaseWebviewProvider{constructor(e,t,i,n){this.container=e,this.host=t,this.repoPath=n,this._enrichment={commits:new Map,authors:new Map,onto:void 0},this._todoDocument=new RebaseTodoDocument(i),this._disposables.push(s.workspace.onDidChangeTextDocument(e=>{!this._closing&&e.document===i&&e.contentChanges.length&&this.updateState()}),s.workspace.onDidSaveTextDocument(e=>{this._closing||e!==i||this.updateState()}),s.workspace.onDidCloseTextDocument(e=>{e===i&&(this._closing=!0,(0,P.mR)(i.uri))}),this.container.subscription.onDidChange(e=>{this.onSubscriptionChanged(e.current)}));const o=this.container.git.getRepository(this.repoPath);null!=o&&this._disposables.push(o.onDidChange(async e=>{e.changed(a.Z_.Rebase,a.Ti.Any)?await (0,D.t2)(this._todoDocument.uri)?this.updateState():this._closing||(this._closing=!0,(0,P.mR)(this._todoDocument.uri)):e.changed(a.Z_.Index,a.Ti.Any)&&this.updateState()}))}_branchName;_closing=!1;_disposables=[];_enrichment;_todoDocument;_context={sessionStart:new Date().toISOString()};get ascending(){return"asc"===_.H.get("rebaseEditor.ordering")}computeIsInPlace(e){e??=this._todoDocument.parsed.processed;let{commits:t,onto:i}=this._enrichment,s=(0,W.$1)(e.commits.keys());if(null==s||i?.sha==null)return!1;let n=t.get(s);return null!=n&&n.parents.some(e=>e.startsWith(i.sha))}dispose(){this._disposables.forEach(e=>void e.dispose())}getSessionDuration(){return Date.now()-new Date(this._context.sessionStart).getTime()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.ascending":this.ascending,"context.todo.count":this._context.todoCount,"context.done.count":this._context.doneCount,"context.isRebasing":this._context.isRebasing,"context.isPaused":this._context.isPaused,"context.preservesMerges":this._context.preservesMerges,"context.hasConflicts":this._context.hasConflicts,"context.session.start":this._context.sessionStart}}async includeBootstrap(e){return e?Promise.resolve({webviewId:this.host.id,webviewInstanceId:this.host.instanceId,timestamp:Date.now()}):this.parseState()}registerCommands(){let e=[];for(let t of eh())e.push(this.host.registerWebviewCommand((0,x.L)(t.command,"rebase"),t.handler.bind(this)));return e}onRefresh(e){this.updateState(!0)}onVisibilityChanged(e){e&&this.updateState()}onSubscriptionChanged(e){this.host.visible&&this.host.notify(es,{subscription:e})}async onAbort(){this.host.sendTelemetryEvent("rebaseEditor/action/abort",{"context.session.duration":this.getSessionDuration()}),this._closing=!0,await this._todoDocument.clear(),await this._todoDocument.save();let e=this.container.git.getRepositoryService(this.repoPath);await (0,r._e)(e),await (0,P.mR)(this._todoDocument.uri)}async onContinue(){this.host.sendTelemetryEvent("rebaseEditor/action/continue"),await this._todoDocument.save();let e=this.container.git.getRepositoryService(this.repoPath);await (0,r.Ts)(e)}async onRecompose(){this.host.sendTelemetryEvent("rebaseEditor/action/recompose",{"context.session.duration":this.getSessionDuration()});let{processed:e}=this._todoDocument.parsed,t=(0,W.$1)(e.commits.keys()),i=this._enrichment.onto.sha,s=(0,W.HV)(e.commits.keys()),{commits:n}=await this.getAndUpdateCommits([s,i,t]),o=n.get(i),r=n.get(t),a=o.sha;r.parents.includes(a)||(a=r.parents[0]);let c=n.get(s).sha;(0,C.RS)("gitlens.showComposerPage",void 0,{repoPath:this.repoPath,source:"rebaseEditor",mode:"preview",branchName:this._branchName??void 0,range:{base:a,head:c}}),await this.onAbort()}async onShowConflicts(){this.host.sendTelemetryEvent("rebaseEditor/action/showConflicts"),await (0,r.jn)(this.container,this.repoPath)}onSearch(){(0,C.S4)("editor.action.webvieweditor.showFind")}async onSkip(){this.host.sendTelemetryEvent("rebaseEditor/action/skip");let e=this.container.git.getRepositoryService(this.repoPath);await (0,r.RG)(e)}async onStart(){this.host.sendTelemetryEvent("rebaseEditor/action/start",{"context.session.duration":this.getSessionDuration()}),this._closing=!0,await this._todoDocument.save(),await (0,P.mR)(this._todoDocument.uri)}async onSwapOrdering(e){let t=this.ascending?"asc":"desc",i=e.ascending?"asc":"desc";this.host.sendTelemetryEvent("rebaseEditor/action/toggleOrdering",{"ordering.old":t,"ordering.new":i}),await _.H.updateEffective("rebaseEditor.ordering",i),this.updateState(!0)}onSwitchToText(){return this.host.sendTelemetryEvent("rebaseEditor/action/switchToText",{"context.session.duration":this.getSessionDuration()}),(0,R.n3)("default")}async onGetMissingAvatars(e){if(!this._enrichment?.authors.size||!this.repoPath)return;let{authors:t}=this._enrichment,i=[],s=!1;for(let[o,r]of Object.entries(e.emails)){let e=(0,W.I6)(t.values(),e=>e.email===o);if(!e)continue;let a=e.avatarUrl??(0,n.m_)(o,{ref:r,repoPath:this.repoPath});if(a instanceof Promise){i.push(a.then(i=>{t.set(e.author,{...e,avatarUrl:i.toString(!0)})}));continue}t.set(e.author,{...e,avatarUrl:a.toString(!0)}),s=!0}(s||i.length)&&(await Promise.allSettled(i),this.notifyDidChangeAvatars())}async onGetMissingCommits(e){if(!e.shas.length||!this.repoPath)return;let{commits:t,authors:i}=await this.getAndUpdateCommits(e.shas);t.size&&this.notifyDidChangeCommits(t,i)}async getAndUpdateCommits(e){if(!e.length||!this.repoPath)return{commits:new Map,authors:new Map};let t=new Map,i=new Map,{authors:s,commits:o}=this._enrichment,r=new Set(e),a=new Set(r);for(let e of a){let i=o.get(e);null!=i&&(a.delete(e),t.set(e,i))}let c=a.size?await this.getCommitsByShas(a):[];for(let e of(0,W.xW)(t.values(),c)){let a=(0,W.I6)(r,t=>e.sha.startsWith(t));if(null==a)continue;o.set(a,e),t.set(a,e),a===this._enrichment.onto?.sha&&(this._enrichment.onto.commit=e);let c=e.author.name,h=s.get(c);null==h&&(h={author:c,email:e.author.email??"",avatarUrl:void 0,avatarFallbackUrl:(0,n.ML)(e.author.email??"",16).toString(!0)},s.set(c,h)),i.set(c,h);let l=e.committer.name;if(l===c)continue;let d=s.get(l);null==d&&(d={author:l,email:e.committer.email??"",avatarUrl:void 0,avatarFallbackUrl:(0,n.ML)(e.committer.email??"",16).toString(!0)},s.set(l,d)),i.set(l,d)}return{commits:t,authors:i}}async onGetPotentialConflicts(e){let{onto:t,commits:i,stopOnFirstConflict:s}=e,n=Date.now(),o=await this.container.subscription.getSubscription();if(!(0,S.aE)(o?.state))return{conflicts:void 0};if(!i?.length)return this.host.sendTelemetryEvent("rebaseEditor/conflicts/detected",{duration:Date.now()-n,status:"clean","commits.count":0}),{conflicts:{status:"clean"}};let r=this.container.git.getRepositoryService(this.repoPath);try{let e=await r.branches.getPotentialApplyConflicts?.(t,i,{stopOnFirstConflict:s}),o=Date.now()-n;return e?.status==="conflicts"?this.host.sendTelemetryEvent("rebaseEditor/conflicts/detected",{duration:o,status:"conflicts","commits.count":i.length,"commits.conflicting":e.conflict.shas?.length??0}):e?.status==="clean"&&this.host.sendTelemetryEvent("rebaseEditor/conflicts/detected",{duration:o,status:"clean","commits.count":i.length}),{conflicts:e}}catch(e){return this.host.sendTelemetryEvent("rebaseEditor/conflicts/failed",{duration:Date.now()-n,"commits.count":i.length,error:e instanceof Error?e.message:String(e)}),{conflicts:void 0}}}async onRevealRef(e){let t=_.H.get("rebaseEditor.revealLocation");if("branch"===e.type){this.host.sendTelemetryEvent("rebaseEditor/action/revealRef",{"ref.type":"branch",location:"graph"});let t=(0,E.kA)(e.ref,this.repoPath,{refType:"branch",name:e.ref,remote:!1});await (0,C.RS)("gitlens.showInCommitGraph",{ref:t,preserveFocus:!0,viewColumn:s.ViewColumn.Beside,source:{source:"rebaseEditor"}});return}this.host.sendTelemetryEvent("rebaseEditor/action/revealRef",{"ref.type":"commit",location:"graph"===t?"graph":"commitDetails"});let i=(0,E.kA)(e.ref,this.repoPath,{refType:"revision"});"graph"===t?await (0,C.RS)("gitlens.showInCommitGraph",{ref:i,preserveFocus:!0,viewColumn:s.ViewColumn.Beside,source:{source:"rebaseEditor"}}):await this.container.views.commitDetails.show({preserveFocus:!0,source:{source:"rebaseEditor"}},{commit:i})}fireSelectionChangedDebounced;onSelectionChanged(e){this.fireSelectionChangedDebounced??=(0,T.s)(this.fireSelectionChanged.bind(this),250),this.fireSelectionChangedDebounced(e)}getRevealBehavior(){let e=_.H.get("rebaseEditor.revealBehavior");return"onOpen"===e||"never"===e?"onDoubleClick":e}async fireSelectionChanged(e){if("onSelection"!==this.getRevealBehavior())return;let{processed:t}=this._todoDocument.parsed,i=t.commits.values(),n=(0,W.I6)(i,t=>t.sha===e.sha);if(null==n)return;let o=this._enrichment?.commits.get(n.sha);if(null==o){if(null==(o=await this.container.git.getRepositoryService(this.repoPath).commits.getCommit(n.sha)))return;this._enrichment.commits.set(n.sha,o)}if("graph"===_.H.get("rebaseEditor.revealLocation")){let e=(0,E.kA)(o.sha,this.repoPath,{refType:"revision"});await (0,C.RS)("gitlens.showInCommitGraph",{ref:e,preserveFocus:!0,viewColumn:s.ViewColumn.Beside,source:{source:"rebaseEditor"}})}else this.container.events.fire("commit:selected",{commit:o,interaction:"passive",preserveFocus:!0,preserveVisibility:!1},{source:"gitlens.rebase"})}async parseState(){let e=this.container.git.getRepositoryService(this.repoPath),{parsed:t,processed:i}=this._todoDocument.parsed,[s,n,o]=await Promise.allSettled([void 0===this._branchName?e.branches.getBranch():void 0,this.getRebaseStatus(e),this.container.subscription.getSubscription()]);void 0===this._branchName&&(this._branchName=(0,M.Ro)(s)?.name??null);let{status:r,doneEntries:a}=(0,M.Ro)(n,{status:void 0,doneEntries:void 0}),c=(0,M.Ro)(o),h=t.info?.onto??r?.onto??"";this._enrichment.onto??={sha:h};let{entries:l}=i,{authors:d,commits:u,onto:m}=this._enrichment,p=_.H.get("defaultDateFormat");return u.size&&(this.enrichEntries(l,u,p),a&&this.enrichEntries(a,u,p)),this._context.todoCount=i.commits.size,this._context.doneCount=a?.filter(e=>"commit"===e.type).length??0,this._context.isRebasing=null!=r,this._context.isPaused=r?.isPaused,this._context.preservesMerges=i.preservesMerges,this._context.hasConflicts=r?.hasConflicts??!1,{webviewId:"gitlens.rebase",webviewInstanceId:this.host.instanceId,timestamp:Date.now(),branch:this._branchName??"",onto:h?{sha:m.sha??h,commit:m?.commit!=null?el(m.commit,p):void 0}:void 0,isInPlace:this.computeIsInPlace(i),entries:l,doneEntries:a,authors:null!=d?Object.fromEntries(d):{},ascending:this.ascending,preservesMerges:i.preservesMerges,density:_.H.get("rebaseEditor.density"),revealLocation:_.H.get("rebaseEditor.revealLocation"),revealBehavior:this.getRevealBehavior(),rebaseStatus:r,repoPath:this.repoPath,subscription:c}}detectPauseReason(e){switch(e){case"edit":return"edit";case"reword":return"reword";case"break":return"break";case"exec":return"exec";default:return}}enrichEntries(e,t,i){for(let s of e){if("commit"!==s.type||null!=s.commit)continue;let e=t.get(s.sha);null!=e&&(s.commit=el(e,i))}}async getCommitsByShas(e){let t=(0,W.fj)((0,W.Tj)(e,e=>`#:${e}`)," "),i=await this.container.git.getRepositoryService(this.repoPath).commits.searchCommits({query:t},{source:"rebaseEditor"},{limit:0});return i.log?.commits.values()??[]}async getDoneEntries(){let e=await y(this._todoDocument.uri);if(!e?.entries.length)return{entries:[]};let t=e.entries.at(-1)?.action;return{entries:b(e.entries,!0).entries,lastAction:t}}async getRebaseStatus(e){let t=await e.pausedOps?.getPausedOperationStatus?.();if(t?.type!=="rebase"||!t.hasStarted)return{status:void 0,doneEntries:void 0};let{entries:i,lastAction:s}=await this.getDoneEntries();if(!i.length)return{status:void 0,doneEntries:void 0};let n=await e.status.hasConflictingFiles(),o=n?"conflict":this.detectPauseReason(s);return{status:{currentStep:t.steps.current.number,totalSteps:t.steps.total,currentCommit:t.steps.current.commit?.ref,hasConflicts:n,isPaused:t.isPaused,pauseReason:o,onto:t.onto.ref},doneEntries:i}}notifyDidChangeAvatars(){if(!this._enrichment?.authors.size||!this.host.visible)return;let e=Object.fromEntries((0,W.x1)(this._enrichment.authors,([e,t])=>t.avatarUrl?[e,t.avatarUrl]:void 0));this.host.notify(et,{avatars:e})}notifyDidChangeCommits(e,t){if(!this.host.visible)return;let i=_.H.get("defaultDateFormat");this.host.notify(ei,{commits:Object.fromEntries((0,W.Tj)(e,([e,t])=>[e,el(t,i)])),authors:Object.fromEntries(t),isInPlace:this.computeIsInPlace()})}async notifyDidChangeState(){if(!this.host.visible)return;let e=await this.parseState();if(!e.entries.length&&!e.doneEntries?.length&&null==e.rebaseStatus){this._closing=!0,await (0,P.mR)(this._todoDocument.uri);return}this.host.notify(ee,{state:e})}notifyDidChangeStateDebounced;updateState(e=!1){if(e){this.notifyDidChangeStateDebounced?.cancel(),this.notifyDidChangeState();return}this.notifyDidChangeStateDebounced??=(0,T.s)(this.notifyDidChangeState.bind(this),250),this.notifyDidChangeStateDebounced()}async onEntryChanged(e){return this.onEntriesChanged({entries:[e]})}async onEntriesChanged(e){e.entries.length&&(this.host.sendTelemetryEvent("rebaseEditor/entries/changed",{action:e.entries[0].action,count:e.entries.length}),await this._todoDocument.changeActions(e.entries))}async onEntryMoved(e){this.host.sendTelemetryEvent("rebaseEditor/entries/moved",{count:1,method:"drag"});let{entries:t}=this._todoDocument.parsed.processed,i=t.findIndex(t=>t.id===e.id);if(-1===i)return;let s=t[i],n=this._todoDocument.calculateMoveTargetIndex(e,i,t.length);if(null==n)return;let o=n>=t.length,r=o?t.length-1:n,a=this._todoDocument.wouldLeaveSquashAsOldest(t,i,r),c=t[r];if(await this._todoDocument.moveEntry(s,c,o,e.relative),a){let e=this._todoDocument.parsed.processed,t=(0,W.$1)(e.commits.values());t&&await this._todoDocument.ensureValidOldestAction(t)}}async onEntriesMoved(e){if(!e.ids.length)return;this.host.sendTelemetryEvent("rebaseEditor/entries/moved",{count:e.ids.length,method:"drag"});let{entries:t}=this._todoDocument.parsed.processed,i=new Set(e.ids),s=t.filter(e=>i.has(e.id));if(!s.length)return;let n=t.filter(e=>!i.has(e.id)),o=Math.max(0,Math.min(e.to,n.length)),r=[...n.slice(0,o),...s,...n.slice(o)],a=r.find(e=>"commit"===e.type),c=a&&("squash"===a.action||"fixup"===a.action);await this._todoDocument.reorderEntries(r,c?a:void 0)}async onEntriesShifted(e){if(!e.ids.length)return;this.host.sendTelemetryEvent("rebaseEditor/entries/moved",{count:e.ids.length,method:"keyboard"});let{entries:t}=this._todoDocument.parsed.processed,i=new Set(e.ids),s=t.map((e,t)=>i.has(e.id)?t:-1).filter(e=>-1!==e);if(!s.length)return;let n=[...t];if("up"===e.direction)for(let e of s){if(0===e)continue;let t=e-1;i.has(n[t].id)||([n[t],n[e]]=[n[e],n[t]])}else for(let e=s.length-1;e>=0;e--){let o=s[e];if(o===t.length-1)continue;let r=o+1;i.has(n[r].id)||([n[r],n[o]]=[n[o],n[r]])}let o=n.find(e=>"commit"===e.type),r=o&&("squash"===o.action||"fixup"===o.action);await this._todoDocument.reorderEntries(n,r?o:void 0)}};function el(e,t){return{sha:e.sha,author:e.author.name,committer:e.committer.name,date:e.formatDate(t),formattedDate:e.formattedDate,message:(0,o.E)(e.message??e.summary)}}er([(0,$.a1)(O),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onAbort",1),er([(0,$.a1)(j),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onContinue",1),er([(0,$.a1)(J),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onRecompose",1),er([ec("gitlens.pausedOperation.showConflicts:"),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onShowConflicts",1),er([(0,$.a1)(Q)],RebaseWebviewProvider.prototype,"onSearch",1),er([(0,$.a1)(q),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onSkip",1),er([(0,$.a1)(U),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onStart",1),er([(0,$.a1)(F),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onSwapOrdering",1),er([(0,$.a1)(B),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onSwitchToText",1),er([(0,$.a1)(X)],RebaseWebviewProvider.prototype,"onGetMissingAvatars",1),er([(0,$.a1)(Y)],RebaseWebviewProvider.prototype,"onGetMissingCommits",1),er([(0,$.YQ)(K)],RebaseWebviewProvider.prototype,"onGetPotentialConflicts",1),er([(0,$.a1)(Z)],RebaseWebviewProvider.prototype,"onRevealRef",1),er([(0,$.a1)(N)],RebaseWebviewProvider.prototype,"onSelectionChanged",1),er([(0,$.a1)(G),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onEntryChanged",1),er([(0,$.a1)(H),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onEntriesChanged",1),er([(0,$.a1)(L),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onEntryMoved",1),er([(0,$.a1)(V),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onEntriesMoved",1),er([(0,$.a1)(z),(0,k.Rm)()],RebaseWebviewProvider.prototype,"onEntriesShifted",1)}};