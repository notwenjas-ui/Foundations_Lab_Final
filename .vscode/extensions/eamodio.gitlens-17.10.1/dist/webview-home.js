exports.id=928,exports.ids=[928],exports.modules={6563(e,t,i){i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var r=i(1398),o=i(1485),s=i(7529),n=i(9701),a=i(9554),h=i(9566),l=i(3783),c=i(2531),p=i(114),g=i(6103),d=i(5467),u=i(5173),m=i(873),v=i(751),w=i(2742),b=i(4615),f=i(5582),y=i(7067),C=i(5362),R=i(5437),S=i(443),P=i(4003),_=i(7809),I=i(3974),B=i(1231),O=i(3290),W=i(7663),k=i(6836),D=i(6611),A=i(6713),H=i(5686),$=i(4170),T=i(4078);async function E(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=$.H.get("launchpad.indicator.groups")??[];return(0,T.a)(t.items,i)}var F=i(4529),M=i(4713),x=i(8075),q=i(5916),U=i(4161),z=i(4257),N=i(8986),L=i(6607),G=i(7775),Q=i(1361),Z=i(2055),V=i(8298),j=i(1396),Y=i(9653),X=i(6066),J=i(6637),K=i(5162),ee=i(2126);let et="home",ei=new ee.Oz(et,"launchpad/summary"),er=new ee.Oz(et,"overview/active"),eo=new ee.Oz(et,"overview/inactive"),es=new ee.Oz(et,"overviewFilter"),en=new ee.Q2(et,"overview/repository/change"),ea=new ee.C1(et,"overview/repository/didChange"),eh=new ee.Q2(et,"previewEnabled/toggle"),el=new ee.Q2(et,"section/collapse"),ec=new ee.Q2(et,"walkthrough/dismiss"),ep=new ee.C1(et,"ai/allAccess/didChange"),eg=new ee.C1(et,"mcp/didChange"),ed=new ee.Q2(et,"ai/allAccess/dismiss"),eu=new ee.Q2(et,"overview/filter/set"),em=new ee.Q2(et,"openInGraph"),ev=new ee.C1(et,"repositories/didCompleteDiscovering"),ew=new ee.C1(et,"previewEnabled/didChange"),eb=new ee.C1(et,"repository/wip/didChange"),ef=new ee.C1(et,"repositories/didChange"),ey=new ee.C1(et,"walkthroughProgress/didChange"),eC=new ee.C1(et,"integrations/didChange"),eR=new ee.C1(et,"launchpad/didChange"),eS=new ee.C1(et,"subscription/didChange"),eP=new ee.C1(et,"org/settings/didChange"),e_=new ee.C1(et,"home/ownerFilter/didChange"),eI=new ee.C1(et,"account/didFocus");var eB=Object.defineProperty,eO=Object.getOwnPropertyDescriptor,eW=e=>{throw TypeError(e)},ek=(e,t,i,r)=>{for(var o,s=r>1?void 0:r?eO(t,i):t,n=e.length-1;n>=0;n--)(o=e[n])&&(s=(r?o(t,i,s):o(s))||s);return r&&s&&eB(t,i,s),s};let eD=Object.freeze({dispose:()=>{}}),eA={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6},{command:eH,getCommands:e$}=(0,z.V)();let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=r.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),r.workspace.isTrusted?eD:r.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,x.wt)(this.onContextChanged,this),this.container.integrations.onDidChange(this.onIntegrationsChanged,this),this.container.integrations.onDidChangeConnectionState(this.onIntegrationConnectionStateChanged,this),this.container.walkthrough.onDidChangeProgress(this.onWalkthroughProgressChanged,this),$.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onLaunchpadChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this),this.container.storage.onDidChange(this.onStorageChanged,this))}_disposable;_discovering;_etag;_etagFileSystem;_etagRepository;_etagSubscription;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1,limit:9}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[r]=i;if(r?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(eI,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onAIModelChanged(e){this.notifyDidChangeIntegrations()}onStorageChanged(e){"global"===e.type&&e.keys.includes("mcp:banner:dismissed")&&this.onMcpBannerChanged()}onIntegrationsChanged(e){this.notifyDidChangeIntegrations()}onIntegrationConnectionStateChanged(e){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),{title:t,placeholder:i}=(0,F.Nt)(this.container.git.openRepositories,"Switch",e?.name),r=await (0,F.oe)(this.container,t,i,this.container.git.openRepositories,{picked:e});if(null!=r&&r!==e)return this.selectRepository(r.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughProgressChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){$.H.changed(e,["home.preview.enabled","ai.enabled","ai.experimental.composer.enabled"])&&this.notifyDidChangeConfig()}onLaunchpadChanged(){this.notifyDidChangeLaunchpad()}async push(e){let t=this.getSelectedRepository();return(0,d.b)({command:"push",state:{repos:t?[t]:void 0,flags:e?.force?["--force"]:void 0}})}async publishBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null!=i)return p.VC(t,void 0,(0,y.iw)(i))}async pull(){let e=this.getSelectedRepository();return(0,d.b)({command:"pull",state:{repos:e?[e]:void 0}})}registerCommands(){let e=[];for(let{command:t,handler:i}of(this.host.is("view")&&e.push((0,M.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,M.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,M.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,M.Lb)(`${this.host.id}.previewFeedback`,()=>(0,q.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,M.Lb)(`${this.host.id}.whatsNew`,()=>(0,q.CZ)(a.DS.releaseNotes),this),(0,M.Lb)(`${this.host.id}.help`,()=>(0,q.CZ)(a.DS.helpCenter),this),(0,M.Lb)(`${this.host.id}.issues`,()=>(0,q.CZ)(a.DS.githubIssues),this),(0,M.Lb)(`${this.host.id}.info`,()=>(0,q.CZ)(a.DS.helpCenterHome),this),(0,M.Lb)(`${this.host.id}.discussions`,()=>(0,q.CZ)(a.DS.githubDiscussions),this)),e$())){let r=(...e)=>{let[t]=e;if((0,X.RR)(t)){let{webview:i,webviewInstance:r,...o}=t;(0,V.xV)(o)?e.splice(0,1,o):e.length=0}return i.call(this,...e)};e.push((0,M.Ip)((0,z.L)(t,this.host.type),r,this))}return e}onSetOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(e_,{filter:this._overviewBranchFilter})}async onGetLaunchpadSummary(){return E(this.container)}onGetOverviewFilterState(){return this._overviewBranchFilter}async onChangeOverviewRepository(){await this.onChooseRepository()!=null&&this.host.notify(ea,void 0)}onGetActiveOverview(){return this.getActiveBranchOverview()}onGetInactiveOverview(){return this.getInactiveBranchOverview()}includeBootstrap(e){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(eI,void 0))}hasRepositoryChanged(){if(this._repositorySubscription?.source!=null){if(this._repositorySubscription.source.etag!==this._etagRepository||this._repositorySubscription.source.etagFileSystem!==this._etagFileSystem)return!0}else if(this._etag!==this.container.git.etag)return!0;return!1}onVisibilityChanged(e){e?(this._repositorySubscription?.resume(),null==this._discovering&&(this.container.subscription.etag!==this._etagSubscription||this.hasRepositoryChanged())&&this.notifyDidChangeRepositories(!0)):this._repositorySubscription?.pause()}showInCommitGraph(e){let t=null!=e?this._repositoryBranches.get(e.repoPath):void 0;if(null==t)return void(0,M.RS)("gitlens.showGraph",this.getSelectedRepository());if("branch"===e.type){let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return void(0,M.RS)("gitlens.showInCommitGraph",{ref:(0,y.iw)(i),source:{source:"home"}})}(0,M.RS)("gitlens.showGraph",t.repo)}openInTimeline(e){let t=null==e?this.getSelectedRepository():this.container.git.getRepository(e.repoPath);if(null!=t){if(e?.type==="repo")return void(0,M.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri});if(e?.type==="branch"){let i=this._repositoryBranches.get(t.path),r=i?.branches.find(t=>t.id===e.branchId);null!=r&&(0,M.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri,head:(0,y.iw)(r)})}}}async openInView(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null==t||null==i)return;let r=await i.getWorktree();null==r||r.isDefault?await (0,h.sT)(i,{select:!0,focus:!0,expand:!0}):await (0,g.dw)(r,{select:!0,focus:!0,expand:!0})}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,M.RS)("gitlens.gitCommands",{command:"branch",state:{subcommand:"create",suggestedRepo:this.getSelectedRepository(),confirmOptions:["--switch","--worktree"]}})}changeBranchMergeTarget(e){this.container.telemetry.sendEvent("home/changeBranchMergeTarget"),(0,M.RS)("gitlens.git.branch.setMergeTarget",{command:"branch",state:{subcommand:"mergeTarget",repo:e.repoPath,reference:e.branchName,suggestedMergeTarget:e.mergeTargetName}})}async mergeIntoCurrent(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.h1(t,(0,y.iw)(i))}async rebaseCurrentOnto(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.RU(t,(0,y.iw)(i))}async explainBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=t&&(0,M.RS)("gitlens.ai.explainBranch",{repoPath:t.path,ref:i?.ref,source:{source:"home",context:{type:"branch"}}})}async explainWip(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null==t)return;let r=await i?.getWorktree();(0,M.RS)("gitlens.ai.explainWip",{repoPath:t.path,worktreePath:r?.path,source:{source:"home",context:{type:"wip"}}})}async composeCommits(e){let{repo:t}=await this.getRepoInfoFromRef(e);null!=t&&(0,M.RS)("gitlens.composeCommits",{repoPath:t.path,source:"home"})}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,M.RS)("gitlens.startWork",{command:"startWork",source:"home"})}async abortPausedOperation(e){await (0,c._e)(this.container.git.getRepositoryService(e.repoPath))}async continuePausedOperation(e){"revert"!==e.type&&await (0,c.Ts)(this.container.git.getRepositoryService(e.repoPath))}async skipPausedOperation(e){await (0,c.RG)(this.container.git.getRepositoryService(e.repoPath))}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.getRepositoryService(e.repoPath).config.getGitDir?.();if(null==t)return;let i=r.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,M.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async showConflicts(e){await (0,c.jn)(this.container,e.repoPath,{openRebaseEditor:!0})}async createCloudPatch(e){let{repo:t}=await this.getRepoInfoFromRef(e);if(null==t)return;let i=await t.git.status.getStatus();if(null==i)return void r.window.showErrorMessage("Unable to create cloud patch");let o=[];for(let e of i.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};o.push(t),e.staged&&e.wip&&o.push({...t,staged:!1})}let s={type:"wip",repository:{name:t.name,path:t.path,uri:t.uri.toString()},files:o,revision:{to:w.SU,from:"HEAD"}};(0,O.X)({mode:"create",create:{changes:[s]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),$.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return this.container.storage.get("home:walkthrough:dismissed")??!1}getWelcomeOverlayCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("welcomeOverlay")??!1}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getAiEnabled(){return this.container.ai.enabled}getExperimentalComposerEnabled(){return $.H.get("ai.experimental.composer.enabled",void 0,!1)}getAmaBannerCollapsed(){return Date.now()>=new Date("2025-02-13T13:00:00-05:00").getTime()||(this.container.storage.get("home:sections:collapsed")?.includes("feb2025AmaBanner")??!1)}getMcpBannerCollapsed(){return!(0,W.W$)(this.container,!0)}getMcpCanAutoRegister(){return(0,W.nA)(this.container)}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}async getAiAllAccessBannerCollapsed(){if(!(0,k.X)())return!0;let e=await this.getAiAllAccessUserId();return this.container.storage.get(`gk:promo:${e}:ai:allAccess:dismissed`,!1)}async getAiAllAccessUserId(){let e=await this.container.subscription.getSubscription();return e.account?.id??"00000000"}async dismissAiAllAccessBanner(){this.container.telemetry.sendEvent("aiAllAccess/bannerDismissed",void 0,{source:"home"});let e=await this.getAiAllAccessUserId();this.container.storage.store(`gk:promo:${e}:ai:allAccess:dismissed`,!0).catch(),await this.onAiAllAccessBannerChanged()}getOrgSettings(){return{drafts:(0,x.SD)("gitlens:gk:organization:drafts:enabled",!1),ai:(0,x.SD)("gitlens:gk:organization:ai:enabled",!0)}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(await this.notifyDidChangeSubscription(e.current),(0,D.aE)(e.current.state)!==(0,D.aE)(e.previous.state)&&this.onOverviewRepoChanged(),await this.onAiAllAccessBannerChanged())}async getState(e){let t,[i,o,s,n]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"}),this.getAiAllAccessBannerCollapsed()]);if("fulfilled"===i.status)t=i.value;else{var a,h,l,c,p,g=[];try{let r=((e,t)=>{if(null!=t){var i,r;let o,s;"object"!=typeof t&&"function"!=typeof t&&eW("Object expected"),void 0===i&&(i=t[o="dispose",(s=Symbol[o])?s:Symbol.for("Symbol."+o)]),"function"!=typeof i&&eW("Object not disposable"),r&&(i=function(){try{r.call(this)}catch(e){return Promise.reject(e)}}),e.push([void 0,i,t])}return t})(g,(0,Z.bP)(`${(0,Q.zu)(this)}.getState(${Q.Vy.toLoggable(e)})`,!1));Q.Vy.error(i.reason,r,"Failed to get subscription state"),this.container.telemetry.sendEvent("home/failed",{reason:"subscription",error:String(i.reason)}),t={subscription:(0,D.RW)(),avatar:`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,organizationsCount:0}}catch(e){var d=e,u=!0}finally{a=d,h=u,l="function"==typeof SuppressedError?SuppressedError:function(e,t,i,r){return(r=Error(i)).name="SuppressedError",r.error=e,r.suppressed=t,r},c=e=>a=h?new l(e,a,"An error was suppressed during disposal"):(h=!0,e),(p=e=>{for(;e=g.pop();)try{var t=e[1]&&e[1].call(e[2]);if(e[0])return Promise.resolve(t).then(p,e=>(c(e),p()))}catch(e){c(e)}if(h)throw a})()}}let m=(0,j.Ro)(o)??[],v=m.some(e=>e.connected),w={model:(0,j.Ro)(s)};return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount,orgSettings:this.getOrgSettings(),aiEnabled:this.getAiEnabled(),experimentalComposerEnabled:this.getExperimentalComposerEnabled(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),aiAllAccessBannerCollapsed:(0,j.Ro)(n,!1),integrations:m,ai:w,hasAnyIntegrationConnected:v,walkthroughSupported:this.container.walkthrough.isWalkthroughSupported,walkthroughProgress:this.getWalkthroughProgress(),previewEnabled:this.getPreviewEnabled(),newInstall:!$.H.get("advanced.skipOnboarding")&&(0,x.SD)("gitlens:install:new",!1),amaBannerCollapsed:this.getAmaBannerCollapsed(),mcpBannerCollapsed:this.getMcpBannerCollapsed(),mcpCanAutoRegister:this.getMcpCanAutoRegister(),welcomeOverlayCollapsed:this.getWelcomeOverlayCollapsed(),hostAppName:r.env.appName}}getPreviewEnabled(){return $.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:r.workspace.isTrusted}}async getActiveBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i="wip"===this._invalidateOverview,[r,o,s]=await Promise.allSettled([this.getBranchesData(e,t),this.isSubscriptionPro(),this.formatRepository(e)]),{branches:n,worktreesByBranch:a}=(0,j.Ro)(r),h=n.find(e=>"active"===this.getBranchOverviewType(e,a)),l=(0,j.Ro)(o),[c]=eT(this.container,[h],a,l,{isActive:!0,forceStatus:!!t||!!i||void 0});return i&&(this._invalidateOverview=void 0),this._etagFileSystem=e.etagFileSystem,{repository:(0,j.Ro)(s),active:c}}async getInactiveBranchOverview(){let e;null!=this._discovering&&await this._discovering;let t=this.getSelectedRepository();if(null==t)return;let i="repo"===this._invalidateOverview,[r,o,s]=await Promise.allSettled([this.getBranchesData(t,i),this.isSubscriptionPro(),this.formatRepository(t)]),{branches:n,worktreesByBranch:a}=(0,j.Ro)(r),h=n.filter(e=>"recent"===this.getBranchOverviewType(e,a)),l=(0,j.Ro)(o);if(this._overviewBranchFilter.stale.show)for(let t of((0,R.Xn)(n,{missingUpstream:!0,orderBy:"date:asc"}),n)){if(null!=e&&e.length>this._overviewBranchFilter.stale.limit)break;h.some(e=>e.id===t.id)||"stale"===this.getBranchOverviewType(t,a)&&(e??=[]).push(t)}let c=eT(this.container,h,a,l),p=null==e?void 0:eT(this.container,e,a,l);return i||(this._invalidateOverview=void 0),{repository:(0,j.Ro)(s),recent:c,stale:p}}async formatRepository(e){let t=await e.git.remotes.getBestRemotesWithProviders(),i=t.find(e=>e.supportsIntegration())??t[0];return(0,C.GS)(e,i)}_repositorySubscription;selectRepository(e){let t;return t=null!=e?this.container.git.getRepository(e):this.container.git.getBestRepositoryOrFirst(),this._repositorySubscription?.dispose(),this._repositorySubscription=void 0,null!=t&&(this._repositorySubscription=new Y.v(t,e=>this.subscribeToRepository(e)),this.host.visible&&this._repositorySubscription.start()),t}resetBranchOverview(){(this._repositoryBranches.clear(),this.host.visible)?this._repositorySubscription?.resume():this._repositorySubscription?.pause()}subscribeToRepository(e){return r.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(t=>this.onOverviewWipChanged(t,e)),e.onDidChange(t=>{t.changed(v.Z_.Config,v.Z_.Head,v.Z_.Heads,v.Z_.Remotes,v.Z_.PausedOperationStatus,v.Z_.Starred,v.Z_.Worktrees,v.Z_.Unknown,v.Ti.Any)&&this.onOverviewRepoChanged(e)}))}onOverviewWipChanged(e,t){e.repository.id!==t.id||this._etagFileSystem===t.etagFileSystem||("repo"!==this._invalidateOverview&&(this._invalidateOverview="wip"),this.host.visible&&this.host.notify(eb,void 0))}onOverviewRepoChanged(e){if(null!=e){if(this._etagRepository===e.etag)return}else if(this._etag===this.container.git.etag)return;this._invalidateOverview="repo",this.host.visible&&this.notifyDidChangeRepositories()}async onAiAllAccessBannerChanged(){this.host.visible&&this.host.notify(ep,await this.getAiAllAccessBannerCollapsed())}onMcpBannerChanged(){this.host.visible&&this.host.notify(eg,{mcpBannerCollapsed:this.getMcpBannerCollapsed(),mcpCanAutoRegister:this.getMcpCanAutoRegister()})}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.source}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)||e.etag!==this._etagRepository){let t=await e.git.worktrees?.getWorktrees()??[],i=(0,S.PU)(t,{includeDefault:!0}),[r]=await Promise.allSettled([e.git.branches.getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,S.vJ)(i)}})]),o=(0,j.Ro)(r)?.values??[];this._etagRepository=e.etag,this._repositoryBranches.set(e.path,{repo:e,branches:o,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,G.x1)(await this.container.integrations.getConfigured(),e=>{if(!(0,n.LT)(e.integrationId))return;let t=n.U4.find(t=>t.id===e.integrationId);return{id:e.integrationId,name:A.Mt[e.integrationId].name,icon:`gl-provider-${A.Mt[e.integrationId].iconKey}`,connected:!0,supports:t?.supports!=null?t.supports:"git"===A.Mt[e.integrationId].type?["prs","issues"]:"issues"===A.Mt[e.integrationId].type?["issues"]:[],requiresPro:t?.requiresPro??!1}}),t=await Promise.allSettled(e),i=[...(0,G.x1)(t,e=>(0,j.Ro)(e))];this._defaultSupportedCloudIntegrations??=n.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>n.rK.indexOf(e.id)-n.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,D.aE)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),this._etagSubscription=this.container.subscription.etag,t=e.account?.email?(0,s.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(ev,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(ef,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e)return void this.notifyDidChangeRepositoriesCore();null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,L.s)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}getWalkthroughProgress(){if(this.getWalkthroughDismissed())return;let e=Object.fromEntries(this.container.walkthrough.getState());return{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress,state:e}}notifyDidChangeProgress(){let e=this.getWalkthroughProgress();null!=e&&this.host.notify(ey,e)}notifyDidChangeConfig(){this.host.notify(ew,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed(),aiEnabled:this.getAiEnabled(),experimentalComposerEnabled:this.getExperimentalComposerEnabled()})}notifyDidChangeLaunchpad(){this.host.notify(eR,void 0)}async notifyDidChangeIntegrations(){let[e,t]=await Promise.allSettled([this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]),i=(0,j.Ro)(e)??[],r=i.some(e=>e.connected),o={model:(0,j.Ro)(t)};r&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(eC,{hasAnyIntegrationConnected:r,integrations:i,ai:o})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(eS,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(eP,{orgSettings:this.getOrgSettings()})}async deleteBranchOrWorktree(e,t){let{repo:i,branch:o}=await this.getRepoInfoFromRef(e);if(null==o)return;let s=!1===o.worktree?void 0:o.worktree??await o.getWorktree();if(o.current&&null!=t&&(!s||s.isDefault)){let i=(0,P.km)(t.branchName),s=await r.window.showWarningMessage(`Before deleting the current branch '${o.name}', you will be switched to '${i}'.`,{modal:!0},{title:"Continue"});if(s?.title!=="Continue")return;try{await this.container.git.getRepositoryService(e.repoPath).ops?.checkout(i)}catch(e){(0,B.VQ)(e,`Unable to switch to branch '${i}'`);return}(0,d.b)({command:"branch",state:{subcommand:"delete",repo:e.repoPath,references:o}})}else if(null!=i&&null!=s&&!s.isDefault){let e=await i.getOrOpenCommonRepository(),t=await i.git.worktrees?.getWorktree(e=>e.isDefault);if(null==t||null==e)return;let s=await r.window.showWarningMessage(`Before deleting the worktree for '${o.name}', you will be switched to the default worktree.`,{modal:!0},{title:"Continue"});if(s?.title!=="Continue")return;let n=$.H.get("deepLinks.schemeOverride"),a="string"==typeof n?n:r.env.uriScheme,h={url:`${a}://${this.container.context.extension.id}/link/${J.vk.Repository}/-/${J.vk.Branch}/${encodeURIComponent(o.name)}?path=${encodeURIComponent(e.path)}&action=delete-branch`,repoPath:e.path,useProgress:!1,state:J.rq.GoToTarget};(0,d.b)({command:"worktree",state:{subcommand:"open",repo:t.repoPath,worktree:t,onWorkspaceChanging:async e=>{await this.container.storage.storeSecret("deepLinks:pending",JSON.stringify(h)),setTimeout(()=>{(0,M.S4)("workbench.action.closeWindow")},2e3)},worktreeDefaultOpen:"current"}})}}async pushBranch(e){try{await this.container.git.getRepositoryService(e.repoPath).ops?.push({reference:{name:e.branchName,ref:e.branchId,refType:"branch",remote:!1,repoPath:e.repoPath,upstream:e.branchUpstreamName?{name:e.branchUpstreamName,missing:!1}:void 0}})}catch(e){u.Vc.is(e)?(0,B.VQ)(e):(0,B.VQ)(e,"Unable to push branch")}}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchName,e.mergeTargetName)}async pullRequestCompare(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to compare");let i=(0,_.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to open changes");let i=(0,_.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestDetails(e){let t=await this.getPullRequestFromRef(e);null==t?r.window.showErrorMessage("Unable to find pull request to open details"):this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate({ref:e,describeWithAI:t,source:i}){let{branch:r}=await this.getRepoInfoFromRef(e);if(null==r)return;let s=await r.getRemote(),n=t?this.container.actionRunners.get("createPullRequest")?.find(e=>e.type===o.do.BuiltIn)?.id:void 0;(0,M.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=s?{name:s.name,provider:null!=s.provider?{id:s.provider.id,name:s.provider.name,domain:s.provider.domain}:void 0,url:s.url}:void 0,branch:{name:r.name,upstream:r.upstream?.name,isRemote:r.remote},describeWithAI:t,source:i},n)}async worktreeOpen(e){let{location:t,...i}=e,{branch:r}=await this.getRepoInfoFromRef(i),o=await r?.getWorktree();null!=o&&(0,U.OH)(o.uri,t?{location:t}:void 0)}async switchToBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);p.S_(t,i?(0,y.iw)(i):void 0)}async fetch(e){if(null==e){let e=this.getSelectedRepository();p.hd(e);return}let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.hd(t,(0,y.iw)(i))}getBranchOverviewType(e,t){if(e.current||t.get(e.id)?.opened)return"active";let i=e.date?.getTime();if(null!=i){let e=Date.now();if(i>e-eA[this._overviewBranchFilter.recent.threshold])return"recent";if(i<e-eA[this._overviewBranchFilter.stale.threshold])return"stale"}if(e.upstream?.missing)return"stale"}async getPullRequestFromRef(e){let{branch:t}=await this.getRepoInfoFromRef(e);return t?.getAssociatedPullRequest()}async getRepoInfoFromRef(e){let t=this.container.git.getRepository(e.repoPath);if(null==t)return{repo:void 0,branch:void 0};if(!e.branchName)return{repo:t,branch:void 0};let i=await t.git.branches.getBranch(e.branchName);return{repo:t,branch:i}}};function eT(e,t,i,r,o){let s,n;if(0===t.length)return[];let a=o?.isActive??!1,h=o?.forceStatus?{force:!0}:void 0,l=new Map,c=new Map,p=new Map,g=new Map,d=new Map,u=new Map,v=new Map,w=[];for(let o of t){o.upstream?.missing===!1&&l.set(o.id,o.getRemote());let t=i.get(o.id),m=o.date?.getTime();!0===r&&(c.set(o.id,eq(e,o,s)),p.set(o.id,o.getEnrichedAutolinks()),g.set(o.id,(0,b.GI)(e,o).then(e=>e.value)),u.set(o.id,e.git.getRepositoryService(o.repoPath).branches.getBranchContributionsOverview(o.ref)),o.current&&v.set(o.id,eM(e,o))),null!=t?d.set(o.id,t.getStatus(h)):!0===a&&(void 0===n&&(n=e.git.getRepositoryService(o.repoPath).status.getStatus()),d.set(o.id,n)),w.push({reference:(0,y.iw)(o),repoPath:o.repoPath,id:o.id,name:o.name,opened:a,timestamp:m,status:o.status,upstream:o.upstream,worktree:t?{name:t.name,uri:t.uri.toString(),isDefault:t.isDefault}:void 0})}return w.length>0&&function(e,t,i,r,o,s,n,a,h,l){for(let c of t){c.remote=r.get(c.id)?.then(async e=>{if(null!=e)return{name:e.name,provider:e.provider?{name:e.provider.name,icon:"remote"===e.provider.icon?"cloud":e.provider.icon,url:await e.provider.url({type:m.J.Repo}),supportedFeatures:e.provider.supportedFeatures}:void 0}}),c.pr=o.get(c.id);let t=s.get(c.id);c.autolinks=t?.then(e=>eE(e));let p=n.get(c.id);c.issues=p?.then(e=>e?.map(e=>({id:e.number||e.id,title:e.title,state:e.state,url:e.url}))??[]),c.wip=eU(e,c,a.get(c.id),i);let g=h.get(c.id);c.contributors=eF(e,g),c.mergeTarget=l.get(c.id)}}(e,w,a,l,c,p,g,d,u,v),w}async function eE(e){return null==e?[]:(await Promise.allSettled((0,G.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eF(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.contributionCount,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eM(e,t){let i,r=await (0,f.Y7)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!r.mergeTargetBranch.paused&&r.mergeTargetBranch.value&&(i=r.mergeTargetBranch.value);let o=i??r.baseBranch??r.defaultBranch;if(null==o)return;let s=e.git.getRepositoryService(t.repoPath),n=await s.branches.getBranch(o);if(null==n)return;let[a,h,l]=await Promise.allSettled([s.commits.getLeftRightCommitCount((0,I.Xn)(n.name,t.ref,"..."),{excludeMerges:!0}),s.branches.getPotentialMergeConflicts?.(t.name,n.name),s.branches.getBranchMergedStatus?.(t,n)]),c=(0,j.Ro)(a),p=null!=c?{ahead:c.right,behind:c.left}:void 0,g=(0,j.Ro)(l);return{repoPath:t.repoPath,id:n.id,name:n.name,status:p,mergedStatus:g,potentialConflicts:(0,j.Ro)(h),targetBranch:n.name,baseBranch:r.baseBranch,defaultBranch:r.defaultBranch}}async function ex(e,t,i){i??=e.launchpad.getCategorizedItems();let r=await i;if(null!=r.error)return;let o=r.items.find(e=>e.url===t.url);if(null==o){if(null!=(r=await e.launchpad.getCategorizedItems({search:[t]})).error)return;o=r.items.find(e=>e.url===t.url)}if(null!=o)return{uuid:o.uuid,category:o.actionableCategory,groups:(0,H._v)(o),suggestedActions:o.suggestedActions,failingCI:o.failingCI,hasConflicts:o.hasConflicts,review:{decision:o.reviewDecision,reviews:o.reviews??[],counts:{approval:o.approvalReviewCount,changeRequest:o.changeRequestReviewCount,comment:o.commentReviewCount,codeSuggest:o.codeSuggestionsCount}},author:o.author,createdDate:o.createdDate,viewer:{...o.viewer,enrichedItems:void 0}}}async function eq(e,t,i){let r=await t.getAssociatedPullRequest({avatarSize:64});if(null!=r)return{id:r.id,url:r.url,state:r.state,title:r.title,draft:r.isDraft,launchpad:ex(e,r,i)}}async function eU(e,t,i,r){if(null==i)return;let[o,s]=await Promise.allSettled([i,r?e.git.getRepositoryService(t.repoPath).pausedOps?.getPausedOperationStatus?.():void 0]),n=(0,j.Ro)(o),a=(0,j.Ro)(s);return{workingTreeState:n?.getDiffStatus(),hasConflicts:n?.hasConflicts,conflictsCount:n?.conflicts.length,pausedOpStatus:a}}ek([eH("gitlens.push:")],HomeWebviewProvider.prototype,"push",1),ek([eH("gitlens.publishBranch:")],HomeWebviewProvider.prototype,"publishBranch",1),ek([eH("gitlens.pull:")],HomeWebviewProvider.prototype,"pull",1),ek([(0,K.a1)(eu)],HomeWebviewProvider.prototype,"onSetOverviewFilter",1),ek([(0,K.YQ)(ei)],HomeWebviewProvider.prototype,"onGetLaunchpadSummary",1),ek([(0,K.YQ)(es)],HomeWebviewProvider.prototype,"onGetOverviewFilterState",1),ek([(0,K.a1)(en)],HomeWebviewProvider.prototype,"onChangeOverviewRepository",1),ek([(0,K.YQ)(er)],HomeWebviewProvider.prototype,"onGetActiveOverview",1),ek([(0,K.YQ)(eo)],HomeWebviewProvider.prototype,"onGetInactiveOverview",1),ek([(0,K.a1)(em),eH("gitlens.showInCommitGraph:"),(0,N.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"showInCommitGraph",1),ek([eH("gitlens.visualizeHistory.branch:"),eH("gitlens.visualizeHistory.repo:"),(0,N.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInTimeline",1),ek([eH("gitlens.openInView.branch:"),(0,N.Rm)({args:{0:e=>`repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInView",1),ek([eH("gitlens.createBranch:"),(0,N.Rm)()],HomeWebviewProvider.prototype,"createBranch",1),ek([eH("gitlens.git.branch.setMergeTarget:"),(0,N.Rm)()],HomeWebviewProvider.prototype,"changeBranchMergeTarget",1),ek([eH("gitlens.mergeIntoCurrent:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"mergeIntoCurrent",1),ek([eH("gitlens.rebaseCurrentOnto:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"rebaseCurrentOnto",1),ek([eH("gitlens.ai.explainBranch:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainBranch",1),ek([eH("gitlens.ai.explainWip:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainWip",1),ek([eH("gitlens.composeCommits:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"composeCommits",1),ek([eH("gitlens.startWork:"),(0,N.Rm)()],HomeWebviewProvider.prototype,"startWork",1),ek([eH("gitlens.pausedOperation.abort:"),(0,N.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"abortPausedOperation",1),ek([eH("gitlens.pausedOperation.continue:"),(0,N.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"continuePausedOperation",1),ek([eH("gitlens.pausedOperation.skip:"),(0,N.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"skipPausedOperation",1),ek([eH("gitlens.pausedOperation.open:"),(0,N.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"openRebaseEditor",1),ek([eH("gitlens.pausedOperation.showConflicts:"),(0,N.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"showConflicts",1),ek([eH("gitlens.createCloudPatch:"),(0,N.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"createCloudPatch",1),ek([(0,K.a1)(eh)],HomeWebviewProvider.prototype,"onTogglePreviewEnabled",1),ek([(0,K.a1)(el)],HomeWebviewProvider.prototype,"onCollapseSection",1),ek([(0,K.a1)(ec),(0,N.Rm)()],HomeWebviewProvider.prototype,"dismissWalkthrough",1),ek([(0,K.a1)(ed),(0,N.Rm)()],HomeWebviewProvider.prototype,"dismissAiAllAccessBanner",1),ek([(0,N.Yz)({args:!1})],HomeWebviewProvider.prototype,"onSubscriptionChanged",1),ek([(0,N.Yz)({args:{0:!1}})],HomeWebviewProvider.prototype,"onOverviewWipChanged",1),ek([(0,N.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1),ek([eH("gitlens.deleteBranchOrWorktree:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`,1:e=>e?.branchId}})],HomeWebviewProvider.prototype,"deleteBranchOrWorktree",1),ek([eH("gitlens.pushBranch:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pushBranch",1),ek([eH("gitlens.openMergeTargetComparison:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}, mergeTargetId: ${e.mergeTargetId}`}})],HomeWebviewProvider.prototype,"mergeTargetCompare",1),ek([eH("gitlens.openPullRequestComparison:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCompare",1),ek([eH("gitlens.openPullRequestChanges:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestChanges",1),ek([eH("gitlens.openPullRequestDetails:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestDetails",1),ek([eH("gitlens.createPullRequest:"),(0,N.Rm)({args:{0:e=>`${e.ref.branchId}, upstream: ${e.ref.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCreate",1),ek([eH("gitlens.openWorktree:"),(0,N.Rm)({args:{0:e=>`${e.branchId}, worktree: ${e.worktree?.name}`}})],HomeWebviewProvider.prototype,"worktreeOpen",1),ek([eH("gitlens.switchToBranch:"),(0,N.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"switchToBranch",1),ek([eH("gitlens.fetch:"),(0,N.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"fetch",1)},9653(e,t,i){i.d(t,{v:()=>SubscriptionManager});let SubscriptionManager=class SubscriptionManager{constructor(e,t){this.source=e,this.subscribe=t}_status="stopped";get status(){return this._status}_subscription;dispose(){this.stop()}start(){(null==this._subscription||"started"!==this._status)&&(this._subscription=this.subscribe(this.source),this._status="started")}pause(){this.stop("paused")}resume(){this.start()}stop(e){this._subscription?.dispose(),this._subscription=void 0,this._status=e??"stopped"}}}};