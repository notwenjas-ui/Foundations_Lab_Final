exports.id=301,exports.ids=[301],exports.modules={7792(e,t,i){i.d(t,{l:()=>o});var a=i(1398),r=i(9554),s=i(5916);async function o(e){if(e.storage.get("confirm:draft:storage",!1))return!0;for(;;){let t={title:"Continue"},i={title:"Cancel",isCloseAffordance:!0},o={title:"Learn More"},n={title:"Security"},c=await a.window.showInformationMessage("Cloud Patches are securely stored by GitKraken and can be accessed by anyone with the link and a GitKraken account.",{modal:!0},t,o,n,i);if(c===t)return e.storage.store("confirm:draft:storage",!0).catch(),!0;if(c===n){(0,s.CZ)(r.DS.security);continue}if(c===o){(0,s.CZ)(r.DS.cloudPatches);continue}return!1}}},7845(e,t,i){i.d(t,{PatchDetailsWebviewProvider:()=>PatchDetailsWebviewProvider});var a=i(1398),r=i(7529),s=i(9554),o=i(4836),n=i(3783),c=i(5173),h=i(8681),l=i(751),d=i(2742),p=i(8256),f=i(3974),u=i(1231),g=i(3290),y=i(7442),w=i(7792),m=i(8211),v=i(4953),C=i(5380),D=i(6607),b=i(1396),_=i(7996);async function x(e,t,i,s){let o=(0,b.v6)(),n=[];function c(e){return e.sort((e,t)=>(e.picked?-1:1)-(t.picked?-1:1)||(0,_.wN)(e.label,t.label))}try{let h=a.window.createQuickPick();if(n.push(h,h.onDidHide(()=>o.fulfill(void 0)),h.onDidAccept(()=>h.busy?void 0:o.fulfill(h.selectedItems.map(e=>e.item))),h.onDidTriggerButton(e=>{e===C.tH&&(h.canSelectMany?h.selectedItems=[]:o.fulfill([]))})),h.ignoreFocusOut=!0,h.title=e,h.placeholder=t,h.matchOnDescription=!0,h.matchOnDetail=!0,h.canSelectMany=s?.multiselect??!0,h.buttons=s?.clearButton?[C.tH]:[],h.busy=!0,h.show(),i=await i,s?.filter!=null&&(i=i.filter(s.filter)),!o.pending)return;let l=i.map(e=>{let t={label:e.name??e.username,description:e.email,picked:s?.picked?.(e)??!1,item:e,iconPath:(0,r.m_)(e.email,void 0)};return t.alwaysShow=t.picked,t});if(!o.pending)return;return h.items=c(l),h.canSelectMany?h.selectedItems=l.filter(e=>e.picked):h.activeItems=l.filter(e=>e.picked),h.busy=!1,n.push(h.onDidChangeSelection((0,D.s)(e=>{if(!h.canSelectMany||h.busy)return;let t=!1;for(let i of h.items){let a=e.includes(i);(i.picked!==a||i.alwaysShow!==a)&&(i.alwaysShow=i.picked=a,t=!0)}t&&(h.items=c([...h.items]),h.selectedItems=e)},10))),await o.promise}finally{n.forEach(e=>void e.dispose())}}var S=i(1044),P=i(4713),k=i(4170),R=i(8075),U=i(7029),W=i(8986),O=i(7775),I=i(8186),M=i(8241);function T(e){if(null!=e)try{return JSON.parse(JSON.stringify(e,M.tG))}catch(e){throw e}}var F=i(6305),E=i(5162),A=i(2126);let V="patchDetails",H=new A.Q2(V,"apply"),Q=new A.Q2(V,"archive"),$=new A.Q2(V,"create"),G=new A.Q2(V,"openInGraph"),L=new A.Q2(V,"checked");new A.Q2(V,"selectRepo"),new A.Q2(V,"selectBase"),new A.Q2(V,"file/actions/execute");let z=new A.Q2(V,"file/open");new A.Q2(V,"file/openOnRemote");let N=new A.Q2(V,"file/compareWorking"),B=new A.Q2(V,"file/comparePrevious"),Z=new A.Q2(V,"preferences/update"),Y=new A.Q2(V,"switchMode"),j=new A.Q2(V,"cloud/copyLink");new A.Q2(V,"local/createPatch");let q=new A.Q2(V,"create/repository/check"),J=new A.Q2(V,"update/create/metadata"),K=new A.Q2(V,"update/draft/metadata"),X=new A.Q2(V,"update/draft/permissions"),ee=new A.Q2(V,"update/users"),et=new A.Q2(V,"update/userSelection"),ei=new A.Oz(V,"explain"),ea=new A.Oz(V,"generate"),er=new A.C1(V,"didChange",!0),es=new A.C1(V,"create/didChange"),eo=new A.C1(V,"draft/didChange"),en=new A.C1(V,"preferences/didChange"),ec=new A.C1(V,"draft/didChangeRepository");new A.C1(V,"org/settings/didChange");let RepositoryRefChangeset=class RepositoryRefChangeset{constructor(e,t,i,a,r,s){this.container=e,this.repository=t,this.revision=i,this.files=a,this.checked=r,this.expanded=s}type="revision";dispose(){}suspend(){}resume(){}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._expanded=e)}async getChange(){return{type:"revision",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:this.files,checked:this.checked,expanded:this.expanded}}};let RepositoryWipChangeset=class RepositoryWipChangeset{constructor(e,t,i,a,r,s){this.container=e,this.repository=t,this.revision=i,this.onDidChangeRepositoryWip=a,this.checked=r,this.expanded=s}type="wip";_disposable;dispose(){this._disposable?.dispose(),this._disposable=void 0}suspend(){this._disposable?.dispose(),this._disposable=void 0}resume(){this._files=void 0,this._expanded&&this.subscribe()}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._files=void 0,e?this.subscribe():(this._disposable?.dispose(),this._disposable=void 0),this._expanded=e)}_files;async getChange(){let e;return this.expanded&&(null==this._files&&(this._files=this.getFiles()),e=await this._files),{type:"wip",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:e?.files,checked:this.checked,expanded:this.expanded}}subscribe(){null==this._disposable&&(this._disposable=a.Disposable.from(this.repository.watchFileSystem(1e3),this.repository.onDidChangeFileSystem(()=>this.onDidChangeWip(),this),this.repository.onDidChange(e=>{e.changed(l.Z_.Index,l.Ti.Any)&&this.onDidChangeWip()})))}onDidChangeWip(){this._files=void 0,this.onDidChangeRepositoryWip(this)}async getFiles(){let e=await this.container.git.getRepositoryService(this.repository.path).status.getStatus(),t=[];if(null!=e)for(let i of e.files){let e={repoPath:i.repoPath,path:i.path,status:i.status,originalPath:i.originalPath,staged:i.staged};t.push(e),i.staged&&i.wip&&t.push({...e,staged:!1})}return{files:t}}};var eh=Object.defineProperty,el=Object.getOwnPropertyDescriptor,ed=(e,t,i,a)=>{for(var r,s=a>1?void 0:a?el(t,i):t,o=e.length-1;o>=0;o--)(r=e[o])&&(s=(a?r(t,i,s):r(s))||s);return a&&s&&eh(t,i,s),s};let PatchDetailsWebviewProvider=class PatchDetailsWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._context={mode:"create",draft:void 0,draftGkDevUrl:void 0,draftUserState:void 0,draftVisibiltyState:void 0,create:void 0,preferences:this.getPreferences(),orgSettings:this.getOrgSettings()},this.setHostTitle(),this.host.description=s.WZ,this._disposable=a.Disposable.from(k.H.onDidChangeAny(this.onAnyConfigurationChanged,this),e.git.onDidChangeRepositories(this.onRepositoriesChanged,this),(0,R.wt)(this.onContextChanged,this))}_context;_disposable;dispose(){this._disposable.dispose()}canReuseInstance(...e){let[t]=e;if(t?.mode==="view"&&null!=t.draft)switch(t.draft.draftType){case"cloud":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.id===t.draft.id;case"local":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.patch.contents===t.draft.patch?.contents}return!1}getTelemetryContext(){return{...this.host.getTelemetryContext()}}async onShowing(e,t,...i){let[a]=i;if(a?.mode==="view"&&null!=a.draft)await this.updateViewDraftState(a.draft),this.trackViewDraft(this._context.draft,a.source);else{this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let e=a?.mode==="create"&&null!=a.create?a.create:{repositories:void 0};this.updateCreateDraftState(e)}return t?.preserveVisibility&&!this.host.visible?[!1,void 0]:[!0,void 0]}includeBootstrap(e){return this.getState(this._context)}registerCommands(){let e=[];return this.host.is("view")&&e.push((0,P.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0)),(0,P.Lb)(`${this.host.id}.close`,()=>this.closeView())),e}onOpenInCommitGraph(e){(0,P.RS)("gitlens.showInCommitGraph",{ref:(0,p.kA)(e.ref,e.repoPath,{refType:"revision"}),source:{source:"patchDetails"}})}onRefresh(){this.updateState(!0)}onReloaded(){this.updateState(!0)}onVisibilityChanged(e){this._context.create?.changes.forEach(t=>e?t.resume():t.suspend()),e&&this.host.sendPendingIpcNotifications()}onAnyConfigurationChanged(e){(k.H.changed(e,["defaultDateFormat","views.patchDetails.files","views.patchDetails.avatars","ai.enabled"])||k.H.changedCore(e,"workbench.tree.renderIndentGuides")||k.H.changedCore(e,"workbench.tree.indent"))&&(this._context.preferences={...this._context.preferences,...this.getPreferences()},this.updateState())}getPreferences(){return{avatars:k.H.get("views.patchDetails.avatars"),dateFormat:k.H.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:k.H.get("views.patchDetails.files"),indentGuides:k.H.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:k.H.getCore("workbench.tree.indent"),aiEnabled:this.container.ai.enabled}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&(this._context.orgSettings=this.getOrgSettings(),this.updateState())}getOrgSettings(){return{ai:(0,R.SD)("gitlens:gk:organization:ai:enabled",!1),byob:(0,R.SD)("gitlens:gk:organization:drafts:byob",!1)}}onRepositoriesChanged(e){if("create"===this.mode&&null!=this._context.create){if(this._context.create?.showingAllRepos)for(let t of e.added)this._context.create.changes.set(t.uri.toString(),new RepositoryWipChangeset(this.container,t,{to:d.SU,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!1,!0));for(let t of e.removed)this._context.create.changes.delete(t.uri.toString());this.notifyDidChangeCreateDraftState()}}onRepositoryWipChanged(e){this.notifyDidChangeCreateDraftState()}get mode(){return this._context.mode}setMode(e,t){this._context.mode=e,this.setHostTitle(e),(0,R.o)("gitlens:views:patchDetails:mode","editor"===k.H.get("cloudPatches.experimental.layout")?void 0:e),t||this.updateState(!0)}setHostTitle(e=this._context.mode){"create"===e?this.host.title="Create Cloud Patch":this._context.draft?.draftType==="cloud"&&"suggested_pr_change"===this._context.draft.type?this.host.title="Cloud Suggestion":this.host.title="Cloud Patch Details"}async onApplyPatch(e){if(null==this._context.draft||"local"===this._context.draft.draftType||!e.selected?.length)return;let t=this._context.draft.changesets?.[0];if(null==t)return;let i="branch"===e.target;for(let r of t.patches)if(e.selected.includes(r.id))try{let e,t=r.commit??await this.getOrCreateCommitForPatch(r.gkRepositoryId);if(!t)continue;if(i){let i=t.getRepository(),o=await (0,v.vt)(`Select a Branch ${s.EO.Dot} ${i?.name}`,i);if(null==o){a.window.showErrorMessage(`Unable to apply patch to '${r.repository.name}': No branch selected`);continue}let n="string"==typeof o;e={branchName:n?o:o.ref,createBranchIfNeeded:n}}await this.container.git.getRepositoryService(t.repoPath).patch?.applyUnreachableCommitForPatch(t.ref,{stash:"prompt",...e}),a.window.showInformationMessage("Patch applied successfully")}catch(e){if(e instanceof o.AL)return;c.ol.is(e,"appliedWithConflicts")?a.window.showWarningMessage("Patch applied with conflicts"):c.ol.is(e)?(0,u.VQ)(e):(0,u.VQ)(e,`Unable to apply patch onto '${r.baseRef}': ${e.message}`)}}closeView(){if((0,R.o)("gitlens:views:patchDetails:mode",void 0),"create"===this._context.mode)this.container.views.drafts.show();else if(this._context.draft?.draftType==="cloud")if("suggested_pr_change"===this._context.draft.type){let e=this._context.draft.changesets?.[0].patches[0].repository;(0,F.$)({type:"wip",repository:ef(e)?e:void 0,source:"patchDetails"})}else this.container.views.drafts.revealDraft(this._context.draft)}onCopyCloudLink(){this._context.draft?.draftType==="cloud"&&a.env.clipboard.writeText(this._context.draft.deepLinkUrl)}async getOrganizationMembers(){return this.container.organizations.getMembers()}async onInviteUsers(){let e,t,i;"create"===this.mode?(i=this._context.create?.userSelections?.map(e=>e.member.id),t=this._context.create?.userSelections?.find(e=>"owner"===e.member.role),e=t?.user):(i=this._context.draftUserState?.selections?.filter(e=>"delete"!==e.change)?.map(e=>e.member.id),e=this._context.draftUserState?.users.find(e=>"owner"===e.role));let a=await x("Select Collaborators","Choose collaborators to share this patch with",this.getOrganizationMembers(),{multiselect:!0,filter:t=>t.id!==e?.userId,picked:e=>i?.includes(e.id)??!1});if(null==a)return;if("create"===this.mode){let e=a.map(e=>eu(e,void 0,"editor","add"));null!=t&&e.push(t),this._context.create.userSelections=e,this.notifyDidChangeCreateDraftState();return}let r=this._context.draftUserState,s=r.selections,o=new Map,n=new Set(a.map(e=>e.id)),c=[];for(let e of s){if(n.has(e.member.id)||"owner"===e.member.role){o.set(e.member.id,e);continue}c.push({...e,change:"delete"})}for(let e of a){let t=o.get(e.id);t?.change==="delete"&&(t.change=void 0),c.push(null!=t?t:eu(e,void 0,"editor","add"))}c.length&&(r.selections=c,this.notifyDidChangeViewDraftState())}onUpdatePatchUserSelection(e){if("create"===this.mode){let t=this._context.create?.userSelections;if(null==t)return;if("remove"===e.role){let i=t.findIndex(t=>t.member.id===e.selection.member.id);if(-1===i)return;t.splice(i,1)}else{let i=t.find(t=>t.member.id===e.selection.member.id);if(null==i)return;i.pendingRole=e.role}this.notifyDidChangeCreateDraftState();return}let t=this._context.draftUserState.selections.find(t=>t.member.id===e.selection.member.id);null!=t&&("remove"===e.role?t.change="delete":(t.change="modify",t.pendingRole=e.role),this.notifyDidChangeViewDraftState())}async onCreateDraft({title:e,changesets:t,description:i,visibility:r,userSelections:s}){if(!await (0,m.G5)(this.container,"Cloud Patches are a Preview feature and require an account.",{source:"cloud-patches",detail:"create"})||!await (0,w.l)(this.container))return;let o=[],n=Object.entries(t),c=1===n.length;for(let[e,t]of n){if(!c&&!1===t.checked)continue;let i=this._context.create?.changes?.get(e);if(null==i)continue;let{revision:a,repository:r}=i;"wip"===t.type&&"staged"===t.checked&&(a={...a,to:d.id}),o.push({repository:r,revision:a})}if(null!=o)try{let t=await this.container.drafts.createDraft("patch",e,o,{description:i,visibility:r});null!=s&&0!==s.length&&await this.container.drafts.addDraftUsers(t.id,s.map(e=>({userId:e.member.id,role:e.pendingRole}))),async function(){let e={title:"View Patch"},i={title:"Copy Link"},r=!1;for(;;){let s=await a.window.showInformationMessage(`Cloud Patch successfully created${r?"â€” link copied to the clipboard":""}`,e,i);if(s===i){a.env.clipboard.writeText(t.deepLinkUrl),r=!0;continue}s===e&&(0,g.X)({mode:"view",draft:t});break}}(),this.container.views.drafts.refresh(!0).then(()=>void this.container.views.drafts.revealDraft(t)),this.closeView()}catch(e){this.notifyDidChangeCreateDraftState(),a.window.showErrorMessage(`Unable to create draft: ${e.message}`)}}async onArchiveDraft({reason:e}){if(this._context.draft?.draftType!=="cloud")return;let t="suggested_pr_change"===this._context.draft.type,i="Cloud Patch";t&&(i="Code Suggestion");try{await this.container.drafts.archiveDraft(this._context.draft,{archiveReason:e}),this._context.draft={...this._context.draft,isArchived:!0,archivedReason:e};let r="archived";if(t)switch(e){case"accepted":r="accepted";break;case"rejected":r="declined"}a.window.showInformationMessage(`${i} successfully ${r}`),this.notifyDidChangeViewDraftState(),t&&this.trackArchiveDraft(this._context.draft)}catch(s){let r="archive";if(t)switch(e){case"accepted":r="accept";break;case"rejected":r="decline"}a.window.showErrorMessage(`Unable to ${r} ${i}: ${s.message}`)}}async trackArchiveDraft(e){let t;e=await this.ensureDraftContent(e);let i=e.changesets?.[0].patches.find(e=>ef(e.repository));(0,l.Z6)(i?.repository)&&(t=await this.container.git.visibility(i.repository.uri));let a=(0,y.y)(e,i);this.host.sendTelemetryEvent("codeSuggestionArchived",{provider:a?.provider,"repository.visibility":t,repoPrivacy:t,draftId:e.id,reason:e.archivedReason},{source:"patchDetails"})}async onExplain(){if(this._context.draft?.draftType!=="cloud")return{error:{message:"Unable to find patch"}};try{let e=await this.getDraftPatch(this._context.draft);if(null==e)throw Error("Unable to find patch");let t=await this.getOrCreateCommitForPatch(e.gkRepositoryId);if(null==t)throw Error("Unable to find commit");let i=await this.container.ai.actions.explainCommit(t,{source:"patchDetails",context:{type:`draft-${this._context.draft.type}`}},{progress:{location:{viewId:this.host.id}}});if("cancelled"===i)throw Error("Operation was canceled");if(null==i)throw Error("Error retrieving content");let{promise:a}=i,r=await a;if("cancelled"===r)throw Error("Operation was canceled");if(null==r)throw Error("Error retrieving content");return{result:r.result}}catch(e){return{error:{message:e.message}}}}async onGenerateDetails(){let e;if(this._context.create?.changes!=null){for(let t of this._context.create.changes.values())if(t.repository){e=t.repository;break}}if(!e)return{error:{message:"Unable to find changes"}};try{let t=await this.container.ai.actions.generateCreateDraft(e,{source:"patchDetails",context:{type:"patch"}},{progress:{location:{viewId:this.host.id}}});if("cancelled"===t)throw Error("Operation was canceled");if(null==t)throw Error("Error retrieving content");return{title:t.result.summary,description:t.result.body}}catch(e){return{error:{message:e.message}}}}async openPatchContents(e){}onPatchChecked(e){if(e.patch.repository.located||!1===e.checked)return;let t=this._context.draft?.changesets?.[0].patches?.find(t=>t.gkRepositoryId===e.patch.gkRepositoryId);null!=t&&this.getOrLocatePatchRepository(t,{prompt:!0,notifyOnLocation:!0})}notifyPatchRepositoryUpdated(e){return this.host.notify(ec,{patch:T({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:ef(e.repository)}})})}onUpdateCreateCheckedState(e){let t=this._context.create?.changes.get(e.repoUri);null!=t&&(t.checked=e.checked,this.notifyDidChangeCreateDraftState())}onUpdateCreateMetadata(e){null!=this._context.create&&(this._context.create.title=e.title,this._context.create.description=e.description,this._context.create.visibility=e.visibility,this.notifyDidChangeCreateDraftState())}onUpdateDraftMetadata(e){null!=this._context.draft&&(this._context.draftVisibiltyState=e.visibility,this.notifyDidChangeViewDraftState())}async onUpdateDraftPermissions(){let e=this._context.draft,t=e.id,i=[];null!=this._context.draftVisibiltyState&&this._context.draftVisibiltyState!==e.visibility&&i.push(this.container.drafts.updateDraftVisibility(t,this._context.draftVisibiltyState));let r=this._context.draftUserState?.selections,s=[];if(null!=r)for(let e of r)void 0!==e.change&&("delete"!==e.change&&s.push({userId:e.member.id,role:e.pendingRole}),"add"!==e.change&&i.push(this.container.drafts.removeDraftUser(t,e.member.id)));(0!==i.length||0!==s.length)&&(0!==i.length&&await Promise.all(i),0!==s.length&&await this.container.drafts.addDraftUsers(t,s),await this.createDraftUserState(e,{force:!0}),a.window.showInformationMessage("Cloud Patch successfully updated"),this.notifyDidChangeViewDraftState())}onSwitchMode(e){this.setMode(e.mode)}_notifyDidChangeStateDebounced=void 0;updateState(e=!1){(this.host.clearPendingIpcNotifications(),e)?this.notifyDidChangeState():(null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,D.s)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced())}async getState(e){let t,i;return"create"===e.mode&&null!=e.create&&(t=await this.getCreateDraftState(e)),"view"===e.mode&&null!=e.draft&&(i=await this.getViewDraftState(e)),T({...this.host.baseWebviewState,mode:e.mode,create:t,draft:i,preferences:e.preferences,orgSettings:e.orgSettings})}async notifyDidChangeState(){return this._notifyDidChangeStateDebounced?.cancel(),this.host.notify(er,{state:await this.getState(this._context)})}updateCreateDraftState(e){let t,i=!1;if(null!=e.changes){t=this._context.create?.changes??new Map;let i=new Set;for(let r of e.changes){let e,s=this.container.git.getRepository(a.Uri.parse(r.repository.uri));null!=s&&(e="wip"===r.type?new RepositoryWipChangeset(this.container,s,r.revision,this.onRepositoryWipChanged.bind(this),r.checked??!0,r.expanded??!0):new RepositoryRefChangeset(this.container,s,r.revision,r.files,r.checked??!0,r.expanded??!0),i.add(s.uri.toString()),t.set(s.uri.toString(),e))}if(i.size!==t.size)for(let[e,a]of t)i.has(e)||(a.checked=!1)}else i=null==e.repositories,t=new Map((e.repositories??this.container.git.openRepositories).map(e=>[e.uri.toString(),new RepositoryWipChangeset(this.container,e,{to:d.SU,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!0,!0)]));this._context.create={title:e.title,description:e.description,changes:t,showingAllRepos:i,visibility:"public"},this.setMode("create",!0),this.notifyDidChangeCreateDraftState()}async getCreateDraftState(e){let{create:t}=e;if(null==t)return;let i={};if(0!==t.changes.size)for(let[e,a]of t.changes){let t=await a.getChange();t?.files?.length!==0&&(t.checked!==a.checked&&(t.checked=a.checked),i[e]=t)}return{title:t.title,description:t.description,changes:i,visibility:t.visibility,userSelections:t.userSelections}}async notifyDidChangeCreateDraftState(){return this.host.notify(es,{mode:this._context.mode,create:await this.getCreateDraftState(this._context)})}async trackViewDraft(e,t){let i;if(e?.draftType!=="cloud"||"suggested_pr_change"!==e.type)return;e=await this.ensureDraftContent(e);let a=e.changesets?.[0].patches.find(e=>ef(e.repository));(0,l.Z6)(a?.repository)&&(i=await this.container.git.visibility(a.repository.uri));let r=(0,y.y)(e,a);this.host.sendTelemetryEvent("codeSuggestionViewed",{provider:r?.provider,"repository.visibility":i,repoPrivacy:i,draftId:e.id,draftPrivacy:e.visibility,source:t},{source:t??"patchDetails"})}async updateViewDraftState(e){this._context.draft=e,e?.draftType==="cloud"&&(this._context.draftGkDevUrl=this.container.drafts.generateWebUrl(e),await this.createDraftUserState(e,{force:!0})),this.setMode("view",!0),this.notifyDidChangeViewDraftState()}async getViewDraftState(e,t=!0){if(null==e.draft)return;let i=e.draft;if("cloud"===i.draftType){!0===t&&ep(i)&&setTimeout(async()=>{await this.ensureDraftContent(i),this.notifyDidChangeViewDraftState(!1)},0);let e=this._context.draftUserState;return{draftType:"cloud",id:i.id,type:i.type,createdAt:i.createdAt.getTime(),updatedAt:i.updatedAt.getTime(),author:{id:i.author.id,name:i.author.name,email:i.author.email,avatar:i.author.avatarUri?.toString()},role:i.role,title:i.title,description:i.description,isArchived:i.isArchived,archivedReason:i.archivedReason,visibility:i.visibility,gkDevLink:this._context.draftGkDevUrl,patches:i.changesets?.length?T(i.changesets[0].patches.map(e=>({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:ef(e.repository)}}))):void 0,users:e.users,userSelections:e.selections}}}async createDraftUserState(e,t){if(null==this._context.draftUserState||t?.force===!0)try{let t=await this.container.drafts.getDraftUsers(e.id);if(0===t.length)return;let i=[],a=[],r=await this.getOrganizationMembers();for(let e of t){i.push(e);let t=r.find(t=>t.id===e.userId);a.push(eu(t,e))}a.sort((e,t)=>((e.pendingRole??e.member.role)==="owner"?-1:1)-((t.pendingRole??t.member.role)==="owner"?-1:1)||e.member.name.localeCompare(t.member.name)),this._context.draftUserState={users:i,selections:a}}catch{}}async notifyDidChangeViewDraftState(e=!0){return this.host.notify(eo,{mode:this._context.mode,draft:T(await this.getViewDraftState(this._context,e))})}onUpdatePreferences(e){(this._context.preferences?.files?.compact!==e.files?.compact||this._context.preferences?.files?.icon!==e.files?.icon||this._context.preferences?.files?.layout!==e.files?.layout||this._context.preferences?.files?.threshold!==e.files?.threshold)&&(null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&k.H.updateEffective("views.patchDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&k.H.updateEffective("views.patchDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&k.H.updateEffective("views.patchDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&k.H.updateEffective("views.patchDetails.files.threshold",e.files?.threshold),this._context.preferences.files=e.files),this.notifyDidChangePreferences())}async notifyDidChangePreferences(){return this.host.notify(en,{preferences:this._context.preferences})}async getDraftPatch(e,t){e.changesets=await this.ensureChangesets(e);let i=null==t?e.changesets[0].patches?.[0]:e.changesets[0].patches?.find(e=>e.gkRepositoryId===t);if(null!=i){if(null==i.contents||null==i.files||null==i.repository){let e=await this.container.drafts.getPatchDetails(i.id);i.contents=e.contents,i.files=e.files,i.repository=e.repository}return i}}async getFileCommitFromParams(e){let[t,i]=await this.getOrCreateCommit(e);return null!=t&&null!=i?[t,new h.l(this.container,e.repoPath,e.path,e.status,e.originalPath,void 0,void 0,e.staged),i]:null!=(t=await t?.getCommitForFile(e.path,e.staged))?[t,t.file,i]:void 0}async getOrCreateCommit(e){switch(this.mode){case"create":return this.getCommitForFile(e);case"view":return[await this.getOrCreateCommitForPatch(e.gkRepositoryId)];default:return[void 0]}}async getCommitForFile(e){let t=(0,O.I6)(this._context.create.changes.values(),t=>t.repository.path===e.repoPath);if(null==t)return[void 0];let i=await t.getChange();if(null==i)return[void 0];if("revision"===i.type){let t=await this.container.git.getRepositoryService(e.repoPath).commits.getCommit(i.revision.to??d.SU);return i.revision.to===i.revision.from||i.revision.from.length===i.revision.to.length+1&&i.revision.from.endsWith("^")&&i.revision.from.startsWith(i.revision.to)?[t]:[t,i.revision]}return"wip"===i.type?[await this.container.git.getRepositoryService(e.repoPath).commits.getCommit(i.revision.to??d.SU)]:[void 0]}async getOrCreateCommitForPatch(e){let t=this._context.draft;if("local"===t.draftType)return;let i=await this.getDraftPatch(t,e);if(i?.repository!=null){if(i?.commit==null){let e=await this.getOrLocatePatchRepository(i,{prompt:!0});if(null==e)return;let r=i.baseRef??"HEAD";for(;;){try{let a=await e.git.patch?.createUnreachableCommitForPatch(r,t.title,i.contents);i.commit=a}catch(t){if(null!=r){let t={title:"Choose Base..."},i={title:"Cancel",isCloseAffordance:!0},s=await a.window.showErrorMessage(`Unable to apply the patch onto ${"HEAD"===r?"HEAD":`'${(0,f.pV)(r)}'`}.
Do you want to try again on a different base?`,{modal:!0},t,i);if(null==s||s===i)break;if(s===t){let t=await (0,S.n)(e.path,"Choose New Base for Patch","Choose a new base to apply the patch onto",{allowedAdditionalInput:{rev:!0},include:["branches","tags","HEAD"]});if(null==t.value)break;r=t.value.ref;continue}}else a.window.showErrorMessage(`Unable to apply the patch on base '${(0,f.pV)(r)}': ${t.message}`)}break}}return i?.commit}}async onOpenFile(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,a]=t;(0,n.Tq)(a,i,{preserveFocus:!0,preview:!0,...e.showOptions})}getChangesTitleNote(){return"view"===this._context.mode&&this._context.draft?.draftType==="cloud"&&"suggested_pr_change"===this._context.draft.type?"Code Suggestion":"Patch"}async onOpenFileComparisonWithPrevious(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,a,r]=t,s=this.getChangesTitleNote();(0,n.eX)(a,null!=r?{repoPath:i.repoPath,rhs:r.to??d.SU,lhs:r.from}:i,{preserveFocus:!0,preview:!0,...e.showOptions,rhsTitle:"view"===this.mode?`${(0,I.P8)(a.path)} (${s})`:void 0}),this.container.events.fire("file:selected",{uri:a.uri},{source:this.host.id})}async onOpenFileComparisonWithWorking(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,a,r]=t,s=this.getChangesTitleNote();(0,n.DD)(a,null!=r?{repoPath:i.repoPath,ref:r.to}:i,{preserveFocus:!0,preview:!0,...e.showOptions,lhsTitle:"view"===this.mode?`${(0,I.P8)(a.path)} (${s})`:void 0})}async getOrLocatePatchRepository(e,t){if(null==e.repository||(0,l.Z6)(e.repository))return e.repository;let i=await this.container.repositoryIdentity.getRepository(e.repository,{openIfNeeded:!0,prompt:t?.prompt??!1});return null==i?a.window.showErrorMessage(`Unable to locate repository '${e.repository.name}'`):(e.repository=i,t?.notifyOnLocation&&this.notifyPatchRepositoryUpdated(e)),i}async ensureChangesets(e){return e.changesets??=await this.container.drafts.getChangesets(e.id),e.changesets}async ensureDraftContent(e){if(!ep(e))return e;e.changesets=await this.ensureChangesets(e);let t=e.changesets.flatMap(e=>e.patches).filter(e=>null==e.contents||null==e.files||null==e.repository);if(0===t.length)return e;for(let e of(await Promise.allSettled(t.map(e=>this.container.drafts.getPatchDetails(e)))))if("fulfilled"===e.status){let i=t.find(t=>t.id===e.value.id);null!=i&&(i.contents=e.value.contents,i.files=e.value.files,i.repository=e.value.repository,await this.getOrLocatePatchRepository(i))}return e}};function ep(e){return null==e.changesets||(0,O.zN)(e.changesets,e=>e.patches.some(e=>null==e.contents||null==e.files||null==e.repository))}function ef(e){return null!=e&&(0,l.Z6)(e)}function eu(e,t,i,a){return{change:a,member:e,user:t,pendingRole:i,avatarUrl:e?.email!=null?(0,r.m_)(e.email,void 0).toString():void 0}}ed([(0,E.a1)(G)],PatchDetailsWebviewProvider.prototype,"onOpenInCommitGraph",1),ed([(0,E.a1)(H)],PatchDetailsWebviewProvider.prototype,"onApplyPatch",1),ed([(0,E.a1)(j)],PatchDetailsWebviewProvider.prototype,"onCopyCloudLink",1),ed([(0,E.a1)(ee)],PatchDetailsWebviewProvider.prototype,"onInviteUsers",1),ed([(0,E.a1)(et)],PatchDetailsWebviewProvider.prototype,"onUpdatePatchUserSelection",1),ed([(0,E.a1)($)],PatchDetailsWebviewProvider.prototype,"onCreateDraft",1),ed([(0,E.a1)(Q)],PatchDetailsWebviewProvider.prototype,"onArchiveDraft",1),ed([(0,E.YQ)(ei)],PatchDetailsWebviewProvider.prototype,"onExplain",1),ed([(0,E.YQ)(ea)],PatchDetailsWebviewProvider.prototype,"onGenerateDetails",1),ed([(0,E.a1)(L)],PatchDetailsWebviewProvider.prototype,"onPatchChecked",1),ed([(0,E.a1)(q)],PatchDetailsWebviewProvider.prototype,"onUpdateCreateCheckedState",1),ed([(0,E.a1)(J)],PatchDetailsWebviewProvider.prototype,"onUpdateCreateMetadata",1),ed([(0,E.a1)(K)],PatchDetailsWebviewProvider.prototype,"onUpdateDraftMetadata",1),ed([(0,E.a1)(X)],PatchDetailsWebviewProvider.prototype,"onUpdateDraftPermissions",1),ed([(0,E.a1)(Y)],PatchDetailsWebviewProvider.prototype,"onSwitchMode",1),ed([(0,W.Yz)({args:!1})],PatchDetailsWebviewProvider.prototype,"getState",1),ed([(0,E.a1)(Z)],PatchDetailsWebviewProvider.prototype,"onUpdatePreferences",1),ed([(0,E.a1)(z)],PatchDetailsWebviewProvider.prototype,"onOpenFile",1),ed([(0,E.a1)(B)],PatchDetailsWebviewProvider.prototype,"onOpenFileComparisonWithPrevious",1),ed([(0,E.a1)(N)],PatchDetailsWebviewProvider.prototype,"onOpenFileComparisonWithWorking",1),ed([(0,U.G)(e=>e.id)],PatchDetailsWebviewProvider.prototype,"ensureChangesets",1)}};