exports.id=0,exports.ids=[0],exports.modules={5338(e,t,i){i.d(t,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var o=i(8039),s=i(1398),n=i(9434),a=i(7529),r=i(9701),l=i(3783),h=i(114),c=i(5467),p=i(5173),m=i(5067),u=i(5994),d=i(873),g=i(751),v=i(2742),w=i(7067),f=i(4138),y=i(7809),C=i(8256),R=i(3974);function S(e,t,i){return e===t||null!=e&&null!=t&&e.query===t.query&&(!i||e.queryFilters.files===t.queryFilters.files&&e.queryFilters.refs===t.queryFilters.refs&&e.queryFilters.type===t.queryFilters.type&&e.matchedFiles.length===t.matchedFiles.length&&e.matchedFiles.every((e,i)=>e.path===t.matchedFiles[i].path))}var b=i(1231),x=i(3290),P=i(7792),D=i(8211),F=i(6713),_=i(6562),k=i(4713),W=i(4170),T=i(8075),q=i(2977),O=i(4257),I=i(8986),A=i(6607),E=i(7775),U=i(1361),H=i(2055);let MRU=class MRU{constructor(e=10,t){this.maxSize=e,this.comparator=t}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let t=null!=this.comparator?this.stack.findIndex(t=>this.comparator(e,t)):this.stack.indexOf(e);-1!==t?this.stack.splice(t,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(e),this._position=0}get(e){if(null!=e){if(e<0||e>=this.stack.length)return;return this.stack[e]}return this.stack.length>0?this.stack[0]:void 0}insert(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(e),this._position++}navigate(e){if(!(this.stack.length<=1)){if("back"===e){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}};var M=i(1396),L=i(5162),V=i(1654),B=i(6066);function z(e){return null!=e&&(0,B.sc)(e)&&("gitlens.views.commitDetails"===e.webview||"gitlens.views.graphDetails"===e.webview)}function $(e){return null!=e&&null!=e&&z(e)&&"object"==typeof e.webviewItemValue&&"file"===e.webviewItemValue.type}function N(e,t){let{path:i,repoPath:o,sha:s}=t,n=e.git.getRepositoryService(o);return null==s||(0,R._k)(s)?n.getAbsoluteUri(i,o):n.getRevisionUri(s,i)}async function G(e,t){let{path:i,repoPath:o,sha:s,staged:n,stashNumber:a}=t,r=e.git.getRepositoryService(o);if(null!=a){let e=await r.stash?.getStash(),t=e?.stashes.get(s);if(null==t)return[];let o=await t.findFile(i);return null!=t&&null!=o?[t,o]:[]}if((0,R._k)(s)){let e=await r.commits.getCommit(v.SU);return e=await e?.getCommitForFile(i,n),e?.file!=null?[e,e.file]:[]}let l=N(e,t);if(null==l)return[];let h=await r.commits.getCommitForFile(l,s);return h?.file!=null?[h,h.file]:[]}var Y=i(3392),j=Object.defineProperty,Q=Object.getOwnPropertyDescriptor,K=(e,t,i,o)=>{for(var s,n=o>1?void 0:o?Q(t,i):t,a=e.length-1;a>=0;a--)(s=e[a])&&(n=(o?s(t,i,n):s(n))||n);return o&&n&&j(t,i,n),n};let{command:X,getCommands:Z}=(0,O.V)();let CommitDetailsWebviewProvider=class CommitDetailsWebviewProvider{constructor(e,t,i){this.container=e,this.host=t,this.options=i,this._context={mode:"commit",inReview:!1,navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commitState:{commit:void 0,searchContext:void 0},autolinksEnabled:W.H.get("views.commitDetails.autolinks.enabled"),experimentalComposerEnabled:W.H.get("ai.experimental.composer.enabled",void 0,!1),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0,orgSettings:this.getOrgSettings(),hasAccount:void 0,hasIntegrationsConnected:void 0},this._disposable=s.Disposable.from(W.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,T.wt)(this.onContextChanged,this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),e.integrations.onDidChange(this.onIntegrationsChanged,this))}_context;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,(e,t)=>e.ref===t.ref);get commit(){return this._context.commitState.commit}get searchContext(){return this._context.commitState.searchContext}dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}getTelemetrySource(){return"graph"===this.options.attachedTo?"graph-details":"inspect"}getTelemetryContext(){let e;if("wip"===this.mode){let t=this._context.wip?.repo;e={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":+(this._context.wip?.pullRequest!=null),"context.inReview":this._context.inReview,"context.codeSuggestions":this._context.wip?.codeSuggestions?.length??0,"context.repository.id":t?.idHash,"context.repository.scheme":t?.uri.scheme,"context.repository.closed":t?.closed,"context.repository.folder.scheme":t?.folder?.uri.scheme,"context.repository.provider.id":t?.provider.id}}else e={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":+(null!=this._context.pullRequest)+(this._context.autolinkedIssues?.length??0),"context.pinned":this._context.pinned,"context.type":null==this.commit?void 0:(0,u.kk)(this.commit)?"stash":"commit","context.uncommitted":this.commit?.isUncommitted??!1};return e}_skipNextRefreshOnVisibilityChange=!1;_shouldRefreshPullRequestDetails=!1;async onShowing(e,t,...i){let[o]=i;return o?.type==="wip"?[await this.onShowingWip(o),this.getTelemetryContext()]:[await this.onShowingCommit(o,t),this.getTelemetryContext()]}get inReview(){return this._context.inReview}async onShowingWip(e,t){this._context.source=e.source;let i=null!=e.inReview&&this.inReview!==e.inReview;return"wip"!==this.mode||null!=e.repository&&this._context.wip?.repo!==e.repository?(i&&null!=e.inReview&&(this._context.inReview=e.inReview),await this.setMode("wip",e.repository),i&&!0===e.inReview&&this.trackOpenReviewMode(e.source)):i&&await this.setInReview(e.inReview,e.source),(!t?.preserveVisibility||!!this.host.visible)&&("launchpad"===e.source&&this.host.visible&&(this._shouldRefreshPullRequestDetails=!0,this.onRefresh()),!0)}async onShowingCommit(e,t){let i,o;if((0,V.c)(e)){let{commit:t}=e.state;t?.repoPath!=null&&t?.sha!=null&&(i=null!=t.stashNumber?{commit:(0,C.kA)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,C.kA)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else i=null!=e&&"object"==typeof e?e:void 0;if(null!=i&&(i.preserveFocus&&(null==t?t={preserveFocus:!0}:t.preserveFocus=!0),{commit:o,...i}=i),null!=o&&"wip"===this.mode&&i?.interaction!=="passive"&&await this.setMode("commit"),null==o&&!this._pinned){let e=this.getBestCommitOrStash();o=e.commit,null==i?i={searchContext:e.searchContext}:null==i.searchContext&&(i={...i,searchContext:e.searchContext})}return null==o||this.commit?.ref.startsWith(o.ref)&&S(i?.searchContext,this.searchContext,!1)||await this.updateCommitState(o,i?.searchContext,{pinned:!1}),(!i?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}async trackOpenReviewMode(e){if(this._context.wip?.pullRequest==null)return;let t=this._context.wip.pullRequest.provider.id,i=await this.container.git.visibility(this._context.wip.repo.path),o=this._context.wip.changes?.files.length??0;this.host.sendTelemetryEvent("openReviewMode",{provider:t,"repository.visibility":i,repoPrivacy:i,source:e??this.getTelemetrySource(),filesChanged:o})}includeBootstrap(e){return e?Promise.resolve({webviewId:this.host.id,webviewInstanceId:this.host.instanceId,timestamp:Date.now()}):this.getState(this._context)}registerCommands(){let e=[(0,k.Ip)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))];for(let{command:t,handler:i}of Z())e.push((0,k.Ip)((0,O.L)(t,this.host.type),i,this));return e}onFocusChanged(e){this._focused!==e&&(this._focused=e,e&&this.isLineTrackerSuspended&&this.ensureTrackers())}getEncodedEntityid(e=this._context.wip?.pullRequest){if(null==e)return;let t=(0,_.Dz)(e);if(null!=t)return o.EntityIdentifierUtils.encode(t)}async trackCreateCodeSuggestion(e,t){if(this._context.wip?.pullRequest==null)return;let i=this._context.wip.pullRequest.provider.id,o=await this.container.git.visibility(this._context.wip.repo.path);this.host.sendTelemetryEvent("codeSuggestionCreated",{provider:i,"repository.visibility":o,repoPrivacy:o,draftId:e.id,draftPrivacy:e.visibility,filesChanged:t,source:"reviewMode"},{source:"inspect-overview",detail:{reviewMode:!0}})}async onSuggestChanges(e){if(!await (0,D.G5)(this.container,"Code Suggestions are a Preview feature and require an account.",{source:"code-suggest",detail:"create"})||!await (0,P.l)(this.container))return;let t=[],i=Object.entries(e.changesets),n=1===i.length,a=0;for(let[e,o]of i){if(!n&&!1===o.checked)continue;let e=this._context.wip.repo.id===o.repository.path?this._context.wip.repo:void 0;if(null==e)continue;let{checked:i}=o,s={to:v.SU,from:"HEAD"};"staged"===i&&(s={...s,to:v.id});let r=this.getEncodedEntityid();null!=r&&(o.files&&o.files.length>0&&("staged"===i?a+=o.files.filter(e=>!0===e.staged).length:a+=o.files.length),t.push({repository:e,revision:s,prEntityId:r}))}if(0!==t.length)try{let i=(0,_.Dz)(this._context.wip.pullRequest),n=o.EntityIdentifierUtils.encode(i),r={description:e.description,visibility:"provider_access",prEntityId:n},l=await this.container.drafts.createDraft("suggested_pr_change",e.title,t,r);(async function(){let e={title:"View Code Suggestions"},t={title:"Copy Link"},i=!1;for(;;){let o=await s.window.showInformationMessage(`Code Suggestion successfully created${i?"â€” link copied to the clipboard":""}`,e,t);if(o===t){s.env.clipboard.writeText(l.deepLinkUrl),i=!0;continue}o===e&&(0,x.X)({mode:"view",draft:l,source:"notification"});break}})(),this.setInReview(!1),this.trackCreateCodeSuggestion(l,a)}catch(e){s.window.showErrorMessage(`Unable to create draft: ${e.message}`)}}getRepoActionPath(){return"wip"===this._context.mode?this._context.wip?.repo.path:this.commit?.repoPath}onFetch(){let e=this.getRepoActionPath();null!=e&&h.hd(e)}onPublish(){let e=this.getRepoActionPath();null!=e&&(0,k.wS)("git.publish",s.Uri.file(e))}onPush(){let e=this.getRepoActionPath();null!=e&&h.VC(e)}onPull(){let e=this.getRepoActionPath();null!=e&&h.a$(e)}onSwitch(){let e=this.getRepoActionPath();null!=e&&h.S_(e)}get pullRequestContext(){if("wip"===this.mode){if(this._context.wip?.pullRequest==null)return;return{repoPath:this._context.wip.repo.path,branch:this._context.wip.branch,pr:this._context.wip.pullRequest}}if(null!=this._context.pullRequest)return{repoPath:this.commit.repoPath,commit:this.commit,pr:this._context.pullRequest}}onOpenPullRequestChanges(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,y.tI)(e,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}onOpenPullRequestComparison(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,y.tI)(e,t.refs);this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async onOpenPullRequestOnRemote(e){if(null==this.pullRequestContext)return;let{pr:{url:t}}=this.pullRequestContext;return(0,k.RS)("gitlens.openPullRequestOnRemote",{pr:{url:t},clipboard:e})}async onShowPullRequestDetails(){if(null==this.pullRequestContext)return;let{pr:e,repoPath:t,branch:i,commit:o}=this.pullRequestContext;if(null!=e)return this.container.views.pullRequest.showPullRequest(e,o??i??t)}onRefresh(e){if(!this._pinned)if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=e?s.Uri.parse(e):void 0))}else{let{commit:e,searchContext:t}=this.getBestCommitOrStash();this.updateCommitState(e,t,{immediate:!1})}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(e){if(this.ensureTrackers(),!e)return;let t=this._skipNextRefreshOnVisibilityChange;t&&(this._skipNextRefreshOnVisibilityChange=!1),t||this.onRefresh(),this.notifyDidChangeState(!0)}onAnyConfigurationChanged(e){(W.H.changed(e,["defaultDateFormat","defaultDateStyle","views.commitDetails.files","views.commitDetails.avatars","ai.enabled"])||W.H.changedCore(e,"workbench.tree.renderIndentGuides")||W.H.changedCore(e,"workbench.tree.indent"))&&(this._context.preferences=this.getPreferences(),this.notifyDidChangeState()),null!=this.commit&&W.H.changed(e,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&this.updateCommitState(this.commit,this.searchContext,{force:!0})}onSubscriptionChanged(e){this.updateCodeSuggestions(),this.updateHasAccount(e.current)}updateHasAccount(e){let t=null!=e.account;this._context.hasAccount!==t&&this.notifyDidChangeHasAccount(t)}async getHasAccount(e=!1){return(null==this._context.hasAccount||e)&&(this._context.hasAccount=(await this.container.subscription.getSubscription())?.account!=null),this._context.hasAccount}async onIntegrationsChanged(e){let t=this._context.hasIntegrationsConnected,i=await this.getHasIntegrationsConnected(!0);t!==i&&this.notifyDidChangeIntegrations(i)}async getHasIntegrationsConnected(e=!1){if(e||null==this._context.hasIntegrationsConnected){let e=await this.container.integrations.getConfigured();e.length?this._context.hasIntegrationsConnected=e.some(e=>(0,r.LT)(e.integrationId)):this._context.hasIntegrationsConnected=!1}return this._context.hasIntegrationsConnected}getPreferences(){return{pullRequestExpanded:this.container.storage.getWorkspace("views:commitDetails:pullRequestExpanded")??!0,avatars:W.H.get("views.commitDetails.avatars"),dateFormat:W.H.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",dateStyle:W.H.get("defaultDateStyle")??"relative",files:W.H.get("views.commitDetails.files"),indentGuides:W.H.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:W.H.getCore("workbench.tree.indent"),aiEnabled:this.container.ai.enabled,showSignatureBadges:W.H.get("signing.showSignatureBadges")}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&this.notifyDidChangeOrgSettings()}getOrgSettings(){return{ai:(0,T.SD)("gitlens:gk:organization:ai:enabled",!1),drafts:(0,T.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onCommitSelected(e){if(null!=e.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===e.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==e.source)){if("graph"===this.options.attachedTo)return void(e.data.commit.ref===v.SU?"wip"!==this.mode?this.setMode("wip",this.container.git.getRepository(e.data.commit.repoPath)):e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath)):(this._pinned&&"passive"===e.data.interaction&&(this._commitStack.insert((0,w.rd)(e.data.commit)),this.updateNavigation()),"commit"!==this.mode&&this.setMode("commit",this.container.git.getRepository(e.data.commit.repoPath)),this._pinned&&"passive"===e.data.interaction||this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data)));if("wip"===this.mode){e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath));return}this._pinned&&"passive"===e.data.interaction?(this._commitStack.insert((0,w.rd)(e.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if((this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible)&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:e}=this.container;this._lineTrackerDisposable=e.subscribe(this,e.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}onCreatePatchFromWip(e){if(null==e.changes)return;let t={type:"wip",repository:{name:e.changes.repository.name,path:e.changes.repository.path,uri:e.changes.repository.uri},files:e.changes.files,revision:{to:v.SU,from:"HEAD"},checked:e.checked};(0,x.X)({mode:"create",create:{changes:[t]}})}onShowCodeSuggestion(e){let t=this._context.wip?.codeSuggestions?.find(t=>t.id===e.id);null!=t&&(0,x.X)({mode:"view",draft:t,source:this.getTelemetrySource()})}onActiveEditorLinesChanged(e){if(e.pending||null==e.editor||e.suspended)return;if("wip"===this.mode){let t=this.container.git.getBestRepositoryOrFirst(e.editor);this.updateWipState(t,!0);return}let t=e.selections?.[0]?.active,i=null!=t?this.container.lineTracker.getState(t)?.commit:void 0;this.updateCommitState(i,void 0)}_wipSubscription;get mode(){return this._context.mode}async setMode(e,t){this._context.mode=e,this.notifyDidChangeState(!0),"wip"===e&&await this.updateWipState(t??this.container.git.getBestRepositoryOrFirst()),this.updateTitle()}updateTitle(){if("commit"===this.mode)if(null==this.commit)this.host.title=this.host.originalTitle;else{let e="Commit Details";"stash"===this.commit.refType?e="Stash Details":this.commit.isUncommitted&&(e="Uncommitted Changes"),this.host.title=`${this.host.originalTitle}: ${e}`}else this.host.title=`${this.host.originalTitle}: Overview`}async onExplainRequest(){try{if(null!=this.commit&&(this.commit.isUncommitted||this.commit.isUncommittedStaged))await (0,k.RS)("gitlens.ai.explainWip",{repoPath:this.commit.repoPath,source:{source:this.getTelemetrySource(),context:{type:"wip"}}});else{let e=(0,u.kk)(this.commit);await (0,k.RS)(e?"gitlens.ai.explainStash":"gitlens.ai.explainCommit",{repoPath:this.commit.repoPath,rev:this.commit.sha,source:{source:this.getTelemetrySource(),context:{type:e?"stash":"commit"}}})}return{result:{summary:"",body:""}}}catch(e){return{error:{message:e.message}}}}async onGenerateRequest(){let e=this._context.wip?.repo;if(!e)return{error:{message:"Unable to find changes"}};try{let t=await this.container.ai.actions.generateCreateDraft(e,{source:this.getTelemetrySource(),context:{type:"suggested_pr_change"}},{progress:{location:{viewId:this.host.id}}});if("cancelled"===t)throw Error("Operation was canceled");if(null==t)throw Error("Error retrieving content");return{title:t.result.summary,description:t.result.body}}catch(e){return{error:{message:e.message}}}}async onReachabilityRequest(){let e=Date.now();try{let t=this.commit;if(null==t)return{error:{message:"Unable to find commit"},duration:Date.now()-e};let i=await this.container.git.getRepositoryService(t.repoPath).commits.getCommitReachability?.(t.sha,this._cancellationTokenSource?.token),o=Date.now()-e;return this.host.sendTelemetryEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/reachability/loaded`,{"refs.count":i?.refs.length??0,duration:o}),{refs:i?.refs??[],duration:o}}catch(o){let t=Date.now()-e,i=o instanceof Error?o.message:String(o);return this.host.sendTelemetryEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/reachability/failed`,{duration:t,"failed.reason":o instanceof Error&&"CancellationError"===o.name?"timeout":"git-error","failed.error":i}),{error:{message:"Failed trying to find branches or tags that contain this commit"},duration:t}}}onNavigateStack(e){let t=this._commitStack.navigate(e.direction);null!=t&&this.updateCommitState(t,void 0,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(e){let t;null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=e.commitState.commit&&(t=await this.getDetailsModel(e.commitState.commit,e.formattedMessage));let i=e.wip;if(null==i&&this._repositorySubscription){null==this._cancellationTokenSource&&(this._cancellationTokenSource=new s.CancellationTokenSource);let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateWipState(this._repositorySubscription?.repo)},100)}return e.hasAccount??=await this.getHasAccount(),e.hasIntegrationsConnected??=await this.getHasIntegrationsConnected(),{...this.host.baseWebviewState,mode:e.mode,commit:t,navigationStack:e.navigationStack,pinned:e.pinned,preferences:e.preferences,autolinksEnabled:e.autolinksEnabled,experimentalComposerEnabled:e.experimentalComposerEnabled,autolinkedIssues:e.autolinkedIssues,pullRequest:e.pullRequest,wip:J(i),orgSettings:e.orgSettings,inReview:e.inReview,hasAccount:e.hasAccount,hasIntegrationsConnected:e.hasIntegrationsConnected,searchContext:e.commitState.searchContext}}async updateWipState(e,t=!1){let i;if(null!=this._wipSubscription){let{repo:i,subscription:o}=this._wipSubscription;if(e?.path!==i.path)o.dispose(),this._wipSubscription=void 0;else if(t)return}let o=this.inReview;if(null!=e){null==this._wipSubscription&&(this._wipSubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)});let t=await this.getWipChange(e);if(i={changes:t,repo:e,repositoryCount:this.container.git.openRepositoryCount},null!=t){let o=await this.getWipBranchDetails(e,t.branchName);null!=o&&(i.branch=o.branch,i.pullRequest=o.pullRequest,i.codeSuggestions=o.codeSuggestions)}if(i.pullRequest?.state!=="opened"&&(o=!1),this._shouldRefreshPullRequestDetails&&null!=i.pullRequest&&"launchpad"===this._context.source&&(this.container.views.pullRequest.showPullRequest(i.pullRequest,i.branch??e.path),this._shouldRefreshPullRequestDetails=!1),await this.host.notify(Y.u,{wip:J(i),inReview:o})){this._context.wip=i,this._context.inReview=o;return}}this._context.wip=i,this._context.inReview=o,this.notifyDidChangeState(!0)}async getWipBranchDetails(e,t){let i=await e.git.branches.getBranch(t);if(null==i)return;if("commit"===this.mode)return{branch:i,pullRequest:void 0,codeSuggestions:[]};let o=await i.getAssociatedPullRequest({expiryOverride:3e5}),s=[];if(null!=o&&(0,F.Ac)(o.provider)){let t=await this.getCodeSuggestions(o,e);t.length&&(s=t)}return{branch:i,pullRequest:o,codeSuggestions:s}}async canAccessDrafts(){return await this.getHasAccount()!==!1&&(0,T.SD)("gitlens:gk:organization:drafts:enabled",!1)}async getCodeSuggestions(e,t){if(!await this.canAccessDrafts()||!(0,F.Ac)(e.provider))return[];let i=await this.container.drafts.getCodeSuggestions(e,t);for(let e of i){if(null!=e.author.avatarUri||null==e.organizationId)continue;let t=e.author.email;if(null==t){let i=await this.container.organizations.getMemberById(e.author.id,e.organizationId);t=i?.email}null!=t&&(e.author.avatarUri=(0,a.m_)(t))}return i}async updateCodeSuggestions(){if("wip"!==this.mode||this._context.wip?.pullRequest==null)return;let e=this._context.wip,{pullRequest:t,repo:i}=e;if(e.codeSuggestions=(0,F.Ac)(t.provider)?await this.getCodeSuggestions(t,i):[],await this.host.notify(Y.u,{wip:J(e)})){this._context.wip=e;return}this._context.wip=e,this.notifyDidChangeState(!0)}_repositorySubscription;async updateCommitState(e,t,i){let o;if(!i?.force&&this.commit?.sha===e?.ref&&S(t,this.searchContext,!1))return;if((0,u.WM)(e))o=e;else if(null!=e)if("stash"===e.refType){let t=await this.container.git.getRepositoryService(e.repoPath).stash?.getStash();o=t?.stashes.get(e.ref)}else o=await this.container.git.getRepositoryService(e.repoPath).commits.getCommit(e.ref);let s=this._context.wip;if(null!=this._repositorySubscription){let{repo:e,subscription:t}=this._repositorySubscription;o?.repoPath!==e.path&&(t.dispose(),this._repositorySubscription=void 0,s=void 0)}if(null==this._repositorySubscription&&null!=o){let e=await this.container.git.getOrOpenRepository(o.repoPath);null!=e&&(this._repositorySubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)},"wip"===this.mode?this.updateWipState(e):s=void 0)}this._context.commitState={commit:o,searchContext:t},this._context.autolinksEnabled=W.H.get("views.commitDetails.autolinks.enabled"),this._context.experimentalComposerEnabled=W.H.get("ai.experimental.composer.enabled",void 0,!1),this._context.formattedMessage=void 0,this._context.autolinkedIssues=void 0,this._context.pullRequest=void 0,this._context.wip=s,i?.pinned!=null&&this.onUpdatePinned({pin:i.pinned}),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=o&&(i?.skipStack||this._commitStack.add((0,w.rd)(o)),this.updateNavigation()),this.notifyDidChangeCommit(i?.immediate??!0),this.updateTitle()}subscribeToRepositoryWip(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onWipChanged(e)),e.onDidChange(t=>{t.changed(g.Z_.Index,g.Ti.Any)&&this.onWipChanged(e)}))}onWipChanged(e){this.updateWipState(e)}async getWipChange(e){let t=await this.container.git.getRepositoryService(e.path).status.getStatus();if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}return{repository:{name:e.name,path:e.path,uri:e.uri.toString()},branchName:t.branch,files:i}}onUpdatePinned(e){e.pin!==this._context.pinned&&(this._pinned=e.pin,this.ensureTrackers(),this._context.pinned=e.pin,this.notifyDidChangeCommit(!0))}onUpdatePreferences(e){if(this._context.preferences?.pullRequestExpanded===e.pullRequestExpanded&&this._context.preferences?.files?.compact===e.files?.compact&&this._context.preferences?.files?.icon===e.files?.icon&&this._context.preferences?.files?.layout===e.files?.layout&&this._context.preferences?.files?.threshold===e.files?.threshold)return;let t={...this._context.preferences};null!=e.pullRequestExpanded&&this._context.preferences?.pullRequestExpanded!==e.pullRequestExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:pullRequestExpanded",e.pullRequestExpanded).catch(),t.pullRequestExpanded=e.pullRequestExpanded),null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&W.H.updateEffective("views.commitDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&W.H.updateEffective("views.commitDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&W.H.updateEffective("views.commitDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&W.H.updateEffective("views.commitDetails.files.threshold",e.files?.threshold),t.files=e.files),this._context.preferences=t,this.notifyDidChangeCommit()}_notifyDidChangeCommitDebounced=void 0;notifyDidChangeCommit(e=!1){e?this.notifyDidChangeState():(this._notifyDidChangeCommitDebounced??=(0,A.s)(this.notifyDidChangeState.bind(this),500),this._notifyDidChangeCommitDebounced())}notifyDidChangeOrgSettings(){this._context.orgSettings=this.getOrgSettings(),this.host.notify(Y.I0,{orgSettings:this._context.orgSettings})}notifyDidChangeHasAccount(e){this._context.hasAccount=e,this.host.notify(Y.A4,{hasAccount:e})}notifyDidChangeIntegrations(e){this._context.hasIntegrationsConnected=e,this.host.notify(Y.IK,{hasIntegrationsConnected:e})}updateNavigation(){let e=this._commitStack.get(this._commitStack.position-1)?.ref;null!=e&&(e=(0,R.pV)(e)),this._context.navigationStack={count:this._commitStack.count,position:this._commitStack.position,hint:e},this.notifyDidChangeCommit()}async onChangeReviewModeCommand(e){await this.setInReview(e.inReview,"inspect-overview")}async setInReview(e,t){if(this.inReview!==e){if(await this.host.notify(Y.LX,{inReview:e})){this._context.inReview=e,e&&null!=t&&this.trackOpenReviewMode(t);return}this._context.inReview=e,this.notifyDidChangeState(!0),e&&null!=t&&this.trackOpenReviewMode(t)}}async notifyDidChangeState(e){let t=(0,H.dQ)();return this._notifyDidChangeCommitDebounced?.cancel(),s.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify(Y.tK,{state:await this.getState(this._context)})}catch(e){U.Vy.error(e,t)}})}getBestCommitOrStash(){let e,t;if(this._pinned)return{commit:void 0,searchContext:void 0};if("graph"!==this.options.attachedTo&&null!=s.window.activeTextEditor){let{lineTracker:t}=this.container,i=t.selections?.[0].active;null!=i&&(e=t.getState(i)?.commit)}if(null==e)if("graph"===this.options.attachedTo){let i=this.container.events.getCachedEventArgsBySource("commit:selected","gitlens.views.graph");e=i?.commit,t=i?.searchContext}else{let i=this.container.events.getCachedEventArgs("commit:selected");e=i?.commit,t=i?.searchContext}return{commit:e,searchContext:t}}async getDetailsModel(e,t){let[i,o,s]=await Promise.allSettled([!e.hasFullDetails()?e.ensureFullDetails({include:{uncommittedFiles:!0}}).then(()=>e):e,e.author.getAvatarUri(e,{size:32}),this.container.git.getRepositoryService(e.repoPath).remotes.getBestRemoteWithIntegration({includeDisconnected:!0})]);e=(0,M.Ro)(i,e);let a=(0,M.Ro)(o),r=(0,M.Ro)(s);t??=this.getFormattedMessage(e,r);let l=null!=e.message?await this.container.autolinks.getAutolinks(e.message,r):void 0;return{repoPath:e.repoPath,sha:e.sha,shortSha:e.shortSha,author:{...e.author,avatar:a?.toString(!0)},committer:{...e.committer,avatar:void 0},message:t,parents:e.parents,stashNumber:"stash"===e.refType?e.stashNumber:void 0,files:e.isUncommitted?e.anyFiles:e.fileset?.files,stats:e.stats,autolinks:null!=l?[...(0,E.Tj)(l.values(),n.U8)]:void 0,enriched:this.getEnrichedState(e,r)}}async getEnrichedState(e,t){var i;let[o,s,n]=await Promise.allSettled([t?.provider!=null&&W.H.get("views.commitDetails.autolinks.enabled")&&W.H.get("views.commitDetails.autolinks.enhanced")?(0,M.zu)(e.getEnrichedAutolinks(t)):void 0,t?.provider!=null&&W.H.get("views.commitDetails.pullRequests.enabled")?e.getAssociatedPullRequest(t):void 0,W.H.get("signing.showSignatureBadges")?e.getSignature():void 0]),a=(0,M.Ro)(o)?.value,r=(0,M.Ro)(s),l=(0,M.Ro)(n),h=null!=a?[...(0,E.x1)(a.values(),([e])=>{var t;return e?.value!=null?{type:(t=e.value).type,provider:{id:t.provider.id,name:t.provider.name,domain:t.provider.domain,icon:t.provider.icon},id:t.id,nodeId:t.nodeId,title:t.title,url:t.url,createdDate:t.createdDate,updatedDate:t.updatedDate,closedDate:t.closedDate,closed:t.closed,state:t.state}:void 0})]:[];return{formattedMessage:this.getFormattedMessage(e,t,a),associatedPullRequest:null!=r?(0,y.pf)(r):void 0,autolinkedIssues:h,signature:null!=l?{status:(i=l).status,format:i.format,signer:i.signer,keyId:i.keyId,fingerprint:i.fingerprint,trustLevel:i.trustLevel,errorMessage:i.errorMessage}:void 0}}getFormattedMessage(e,t,i){let o=m.c.fromTemplate("${message}",e),s=o.indexOf(`
`);return(-1!==s&&(o=`${o.substring(0,s)}${Y.iA}${o.substring(s+1)}`),W.H.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(o,"html",null!=t?[t]:void 0,i):o}async getFileCommitFromContextOrParams(e){return null==e?[]:z(e)?$(e)?G(this.container,e.webviewItemValue):[]:this.getFileCommitFromParams(e)}async getFileCommitFromParams(e){let t;if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;if(null==e)return[];t=await this.container.git.getRepositoryService(s.Uri.parse(e)).commits.getCommit(v.SU)}else t=this.commit;return null!=(t=await t?.getCommitForFile(e.path,e.staged))?[t,t.file]:[]}onShowCommitPicker(){(0,c.b)({command:"log",state:{reference:"HEAD",repo:this.commit?.repoPath,openPickInView:!0}})}onShowCommitSearch(){(0,c.b)({command:"search",state:{openPickInView:!0}})}onExecuteCommitAction(e){switch(e.action){case"graph":{let e;if(null==(e="wip"===this._context.mode?this._context.wip?.changes!=null?(0,C.kA)(v.SU,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this.commit?(0,w.rd)(this.commit):void 0))return;(0,k.RS)("graph"===this.options.attachedTo?"gitlens.showInCommitGraphView":"gitlens.showInCommitGraph",{ref:e,source:{source:this.getTelemetrySource()}});break}case"more":this.showCommitActions();break;case"scm":(0,k.S4)("workbench.view.scm");break;case"sha":null!=this.commit&&(e.alt?(0,k.RS)("gitlens.copyMessageToClipboard",{message:this.commit.message}):(0,u.kk)(this.commit)?s.env.clipboard.writeText(this.commit.stashName):(0,k.RS)("gitlens.copyShaToClipboard",{sha:this.commit.sha}))}}showCommitActions(){null==this.commit||this.commit.isUncommitted||(0,l.G4)(this.commit)}async onShowFileActions(e){let[t,i]=await this.getFileCommitFromParams(e);null!=t&&(this.suspendLineTracker(),(0,l.G4)(t,i))}onSwitchMode(e){let t;if(this.mode===e.mode)return;let i=this.mode;if("wip"===e.mode){let{repoPath:i}=e;if(null==i){if(null==(t=this.container.git.getBestRepositoryOrFirst()))return;i=t.path}else t=this.container.git.getRepository(i)}this.setMode(e.mode,t),this.host.sendTelemetryEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/mode/changed`,{"mode.old":i,"mode.new":e.mode})}async openChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,l.eX)(i,t,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}),this.container.events.fire("file:selected",{uri:i.uri},{source:this.host.id}))}async openFileChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,l.DD)(i,t,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}))}async openPreviousFileChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,l.DD)(i,{repoPath:t.repoPath,ref:t.unresolvedPreviousSha},{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}),this.container.events.fire("file:selected",{uri:i.uri},{source:this.host.id}))}async openFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,l.Tq)(i,t,{preserveFocus:!0,preview:!0}))}async openFileOnRemote(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,l.gV)(i,t)}async stageFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&await this.container.git.getRepositoryService(t.repoPath).staging?.stageFile(i.uri)}async unstageFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&await this.container.git.getRepositoryService(t.repoPath).staging?.unstageFile(i.uri)}getShowOptions(e){return z(e)?void 0:e?.showOptions}async copy(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&s.env.clipboard.writeText(i.path)}async copyRelativePath(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let o=this.container.git.getRelativePath(i.uri,t.repoPath);s.env.clipboard.writeText(o)}async copyPatch(e){let t,[i,o]=await this.getFileCommitFromContextOrParams(e);if(null!=i){if(i.isUncommitted){let e=i.isUncommittedStaged?v.id:v.SU;t={repoPath:i.repoPath,to:e,title:e===v.id?"Staged Changes":"Uncommitted Changes",uris:[o.uri]}}else{null==i.message&&await i.ensureFullDetails();let{summary:e,body:s}=(0,f.TH)(i.message);t={repoPath:i.repoPath,to:i.ref,from:`${i.ref}^`,title:e,description:s,uris:[o.uri]}}(0,k.RS)("gitlens.copyPatchToClipboard",t)}}async openFileRevision(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,l.vM)(i,t,{preserveFocus:!0,preview:!1}))}async openFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.openFileHistory",i.uri)}async quickOpenFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.quickOpenFileHistory",i.uri)}async visualizeFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.visualizeHistory.file",i.uri)}async openFileHistoryInGraph(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.openFileHistoryInGraph",i.uri)}async restoreFile(e){if(!$(e))return;let{path:t,repoPath:i,sha:o}=e.webviewItemValue;if(null!=o&&o!==v.SU)try{await this.container.git.getRepositoryService(i).ops?.checkout(o,{path:t})}catch(e){p.vd.is(e)?(0,b.VQ)(e):(0,b.VQ)(e,"Unable to restore file")}}async restorePreviousFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,l.VX)(i,t,!0)}selectFileForCompare(e){if(!$(e))return;let{repoPath:t,sha:i}=e.webviewItemValue,o=N(this.container,e.webviewItemValue);null!=o&&(0,T.o)("gitlens:views:canCompare:file",{ref:i??v.SU,repoPath:t,uri:o})}async compareFileWithSelected(e){let t=(0,T.SD)("gitlens:views:canCompare:file");if(null==t||!$(e))return;(0,T.o)("gitlens:views:canCompare:file",void 0);let{repoPath:i,sha:o}=e.webviewItemValue;if(t.repoPath!==i)return void this.selectFileForCompare(e);let s=N(this.container,e.webviewItemValue);null!=s&&await this.compareFileWith(t.repoPath,t.uri,t.ref,s,o??v.SU)}async compareFileWith(e,t,i,o,s){return o??=await this.container.git.getRepositoryService(e).getWorkingUri(t),(0,k.RS)("gitlens.diffWith",{repoPath:e,lhs:{sha:i,uri:t},rhs:{sha:s,uri:o??t}})}async applyChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,l.YF)(i,t)}async mergeChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let o=this.container.git.getRepositoryService(t.repoPath);if(null==o)return;let n=await o.getBestRevisionUri(i.path,t.ref);if(null==n)return;let a={uri:n,title:"Incoming",detail:` ${t.shortSha}`},[r,l]=await Promise.allSettled([o.refs.getMergeBase(t.ref,"HEAD"),o.getWorkingUri(i.uri)]),h=(0,M.Ro)(l);if(null==h)return void s.window.showWarningMessage("Unable to open the merge editor, no working file found");let c={uri:h,title:"Current",detail:" Working Tree"},p=await o.getBestRevisionUri(i.path,"HEAD");if(null!=p){let e=await o.branches.getBranch?.();c.uri=p,c.detail=` ${e?.name||"HEAD"}`}let m=(0,M.Ro)(r),u=null!=m?await o.getBestRevisionUri(i.path,m):void 0;return(0,q.g6)({base:u??n,input1:a,input2:c,output:h})}diffWithRevision(e){if(!$(e))return;let t=N(this.container,e.webviewItemValue);null!=t&&(0,k.RS)("gitlens.diffWithRevision",t)}diffWithRevisionFrom(e){if(!$(e))return;let t=N(this.container,e.webviewItemValue);null!=t&&(0,k.RS)("gitlens.diffWithRevisionFrom",t)}async externalDiff(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let o=await t.getPreviousSha(),s=(0,R._k)(o)?"":o,n=t.isUncommitted?"":t.sha;(0,k.RS)("gitlens.externalDiff",{files:[{uri:i.uri,staged:t.isUncommittedStaged,ref1:s,ref2:n}]})}async highlightChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),await (0,l.Tq)(i,t,{preserveFocus:!0,preview:!0}),await this.container.fileAnnotations.toggle(s.window.activeTextEditor,"changes",{sha:t.ref},!0))}async highlightRevisionChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),await (0,l.Tq)(i,t,{preserveFocus:!0,preview:!0}),await this.container.fileAnnotations.toggle(s.window.activeTextEditor,"changes",{sha:t.ref,only:!0},!0))}async copyDeepLinkToCommit(e){let[t]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.copyDeepLinkToCommit",{refOrRepoPath:t})}async copyDeepLinkToFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.copyDeepLinkToFile",{ref:t,filePath:i.path,repoPath:t.repoPath})}async copyDeepLinkToFileAtRevision(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.copyDeepLinkToFileAtRevision",{ref:t,filePath:i.path,repoPath:t.repoPath,chooseRef:!0})}async copyRemoteCommitUrl(e){let[t]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.openOnRemote",{repoPath:t.repoPath,resource:{type:d.J.Commit,sha:t.ref},clipboard:!0})}async shareAsCloudPatch(e){let[t]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;null==t.message&&await t.ensureFullDetails();let{summary:i,body:o}=(0,f.TH)(t.message);(0,k.RS)("gitlens.createCloudPatch",{to:t.ref,repoPath:t.repoPath,title:i,description:o})}async copyRemoteFileUrlFrom(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.copyRemoteFileUrlFrom",{sha:t.ref,clipboard:!0,pickBranchOrTag:!0,range:!1})}async copyRemoteFileUrlWithoutRange(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,k.RS)("gitlens.copyRemoteFileUrlWithoutRange",{sha:t.ref,clipboard:!0,range:!1})}};function J(e){if(null!=e)return{changes:e.changes,repositoryCount:e.repositoryCount,branch:function(e){if(null!=e)return{name:e.name,repoPath:e.repoPath,upstream:e.upstream,tracking:{ahead:e.upstream?.state.ahead??0,behind:e.upstream?.state.behind??0}}}(e.branch),repo:{uri:e.repo.uri.toString(),name:e.repo.name,path:e.repo.path},pullRequest:null!=e.pullRequest?(0,y.pf)(e.pullRequest):void 0,codeSuggestions:e.codeSuggestions?.map(e=>({...e,changesets:void 0}))}}K([(0,L.a1)(Y.zK)],CommitDetailsWebviewProvider.prototype,"onSuggestChanges",1),K([(0,L.a1)(Y.qy)],CommitDetailsWebviewProvider.prototype,"onFetch",1),K([(0,L.a1)(Y.D5)],CommitDetailsWebviewProvider.prototype,"onPublish",1),K([(0,L.a1)(Y.qf)],CommitDetailsWebviewProvider.prototype,"onPush",1),K([(0,L.a1)(Y.z_)],CommitDetailsWebviewProvider.prototype,"onPull",1),K([(0,L.a1)(Y.Cv)],CommitDetailsWebviewProvider.prototype,"onSwitch",1),K([(0,L.a1)(Y.PR)],CommitDetailsWebviewProvider.prototype,"onOpenPullRequestChanges",1),K([(0,L.a1)(Y.N9)],CommitDetailsWebviewProvider.prototype,"onOpenPullRequestComparison",1),K([(0,L.a1)(Y.vL)],CommitDetailsWebviewProvider.prototype,"onOpenPullRequestOnRemote",1),K([(0,L.a1)(Y.mK)],CommitDetailsWebviewProvider.prototype,"onShowPullRequestDetails",1),K([(0,L.a1)(Y.GC)],CommitDetailsWebviewProvider.prototype,"onCreatePatchFromWip",1),K([(0,L.a1)(Y.Iq)],CommitDetailsWebviewProvider.prototype,"onShowCodeSuggestion",1),K([(0,L.YQ)(Y.fF)],CommitDetailsWebviewProvider.prototype,"onExplainRequest",1),K([(0,L.YQ)(Y.Nb)],CommitDetailsWebviewProvider.prototype,"onGenerateRequest",1),K([(0,L.YQ)(Y.L2)],CommitDetailsWebviewProvider.prototype,"onReachabilityRequest",1),K([(0,L.a1)(Y.TC)],CommitDetailsWebviewProvider.prototype,"onNavigateStack",1),K([(0,I.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),K([(0,I.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),K([(0,L.a1)(Y.T$)],CommitDetailsWebviewProvider.prototype,"onUpdatePinned",1),K([(0,L.a1)(Y.Tu)],CommitDetailsWebviewProvider.prototype,"onUpdatePreferences",1),K([(0,L.a1)(Y.jY)],CommitDetailsWebviewProvider.prototype,"onChangeReviewModeCommand",1),K([(0,I.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getEnrichedState",1),K([(0,L.a1)(Y.QY)],CommitDetailsWebviewProvider.prototype,"onShowCommitPicker",1),K([(0,L.a1)(Y.tu)],CommitDetailsWebviewProvider.prototype,"onShowCommitSearch",1),K([(0,L.a1)(Y.k$)],CommitDetailsWebviewProvider.prototype,"onExecuteCommitAction",1),K([(0,L.a1)(Y.xy)],CommitDetailsWebviewProvider.prototype,"onShowFileActions",1),K([(0,L.a1)(Y.b6)],CommitDetailsWebviewProvider.prototype,"onSwitchMode",1),K([(0,L.a1)(Y.UB),X("gitlens.views.openChanges:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openChanges",1),K([(0,L.a1)(Y.Sh),X("gitlens.views.openChangesWithWorking:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFileChangesWithWorking",1),K([X("gitlens.views.openPreviousChangesWithWorking:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openPreviousFileChangesWithWorking",1),K([(0,L.a1)(Y.Yt),X("gitlens.views.openFile:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFile",1),K([(0,L.a1)(Y.Lb),X("gitlens.openFileOnRemote:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFileOnRemote",1),K([(0,L.a1)(Y.eg),X("gitlens.views.stageFile:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"stageFile",1),K([(0,L.a1)(Y.Zr),X("gitlens.views.unstageFile:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"unstageFile",1),K([X("gitlens.views.copy:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copy",1),K([X("gitlens.copyRelativePathToClipboard:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyRelativePath",1),K([X("gitlens.copyPatchToClipboard:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyPatch",1),K([X("gitlens.views.openFileRevision:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFileRevision",1),K([X("gitlens.openFileHistory:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFileHistory",1),K([X("gitlens.quickOpenFileHistory:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"quickOpenFileHistory",1),K([X("gitlens.visualizeHistory.file:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"visualizeFileHistory",1),K([X("gitlens.openFileHistoryInGraph:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"openFileHistoryInGraph",1),K([X("gitlens.restore.file:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"restoreFile",1),K([X("gitlens.restorePrevious.file:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"restorePreviousFile",1),K([X("gitlens.views.selectFileForCompare:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"selectFileForCompare",1),K([X("gitlens.views.compareFileWithSelected:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"compareFileWithSelected",1),K([X("gitlens.views.applyChanges:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"applyChanges",1),K([X("gitlens.views.mergeChangesWithWorking:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"mergeChangesWithWorking",1),K([X("gitlens.diffWithRevision:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"diffWithRevision",1),K([X("gitlens.diffWithRevisionFrom:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"diffWithRevisionFrom",1),K([X("gitlens.externalDiff:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"externalDiff",1),K([X("gitlens.views.highlightChanges:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"highlightChanges",1),K([X("gitlens.views.highlightRevisionChanges:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"highlightRevisionChanges",1),K([X("gitlens.copyDeepLinkToCommit:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToCommit",1),K([X("gitlens.copyDeepLinkToFile:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToFile",1),K([X("gitlens.copyDeepLinkToFileAtRevision:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToFileAtRevision",1),K([X("gitlens.views.copyRemoteCommitUrl:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyRemoteCommitUrl",1),K([X("gitlens.shareAsCloudPatch:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"shareAsCloudPatch",1),K([X("gitlens.copyRemoteFileUrlFrom:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyRemoteFileUrlFrom",1),K([X("gitlens.copyRemoteFileUrlWithoutRange:"),(0,I.Rm)()],CommitDetailsWebviewProvider.prototype,"copyRemoteFileUrlWithoutRange",1)},7792(e,t,i){i.d(t,{l:()=>a});var o=i(1398),s=i(9554),n=i(5916);async function a(e){if(e.storage.get("confirm:draft:storage",!1))return!0;for(;;){let t={title:"Continue"},i={title:"Cancel",isCloseAffordance:!0},a={title:"Learn More"},r={title:"Security"},l=await o.window.showInformationMessage("Cloud Patches are securely stored by GitKraken and can be accessed by anyone with the link and a GitKraken account.",{modal:!0},t,a,r,i);if(l===t)return e.storage.store("confirm:draft:storage",!0).catch(),!0;if(l===r){(0,n.CZ)(s.DS.security);continue}if(l===a){(0,n.CZ)(s.DS.cloudPatches);continue}return!1}}}};