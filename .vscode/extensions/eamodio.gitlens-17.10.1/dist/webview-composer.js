exports.id=407,exports.ids=[407],exports.modules={6342(e,t,o){o.d(t,{ComposerWebviewProvider:()=>ComposerWebviewProvider});var i=o(1398),n=o(8968),s=o(751),a=o(2742),r=o(5582),c=o(7717),m=o(4529),d=o(4713),h=o(4170),l=o(8075),u=o(1396),g=o(6980),p=o(5162),f=o(2126);let C="1.0.0",x={hunks:[],commits:[],baseCommit:null,detailsSectionExpanded:{commitMessage:!0,aiExplanation:!0,filesChanged:!0},generatingCommits:!1,generatingCommitMessage:null,committing:!1,safetyError:null,loadingError:null,aiOperationError:null,hasUsedAutoCompose:!1,hasChanges:!0,workingDirectoryHasChanged:!1,indexHasChanged:!1,mode:"preview",recompose:null,aiEnabled:{org:!1,config:!1},ai:{model:void 0},onboardingDismissed:!1},w={sessionStart:"",sessionDuration:void 0,diff:{files:0,hunks:0,lines:0,staged:!1,unstaged:!1,commits:!1,unstagedIncluded:!1},commits:{initialCount:0,autoComposedCount:void 0,composedCount:void 0,finalCount:void 0},ai:{enabled:{org:!1,config:!1},model:void 0},onboarding:{dismissed:!1,stepReached:void 0},operations:{generateCommits:{count:0,cancelledCount:0,errorCount:0,feedback:{upvoteCount:0,downvoteCount:0}},generateCommitMessage:{count:0,cancelledCount:0,errorCount:0},finishAndCommit:{errorCount:0},undo:{count:0},redo:{count:0},reset:{count:0}},source:void 0,mode:"preview",errors:{safety:{count:0},operation:{count:0}},warnings:{workingDirectoryChanged:!1,indexChanged:!1}},y="composer",_=new f.Q2(y,"generateCommits"),v=new f.Q2(y,"generateCommitMessage"),b=new f.Q2(y,"finishAndCommit"),S=new f.Q2(y,"close"),k=new f.Q2(y,"reload"),E=new f.Q2(y,"cancelGenerateCommits"),I=new f.Q2(y,"cancelGenerateCommitMessage");new f.Q2(y,"cancelFinishAndCommit");let R=new f.Q2(y,"clearAIOperationError"),A=new f.Q2(y,"selectAIModel"),M=new f.Q2(y,"aiFeedbackHelpful"),T=new f.Q2(y,"aiFeedbackUnhelpful"),D=new f.Q2(y,"openOnboarding"),P=new f.Q2(y,"dismissOnboarding"),F=new f.Q2(y,"advanceOnboarding"),$=new f.Q2("composer","chooseRepository"),O=new f.Q2(y,"onAddHunksToCommit"),H=new f.Q2(y,"onUndo"),W=new f.Q2(y,"onRedo"),N=new f.Q2(y,"onReset"),z=new f.C1(y,"didStartGenerating"),U=new f.C1(y,"didStartGeneratingCommitMessage"),B=new f.C1(y,"didGenerateCommits"),G=new f.C1(y,"didGenerateCommitMessage"),Q=new f.C1(y,"didStartCommitting"),j=new f.C1(y,"didFinishCommitting"),V=new f.C1(y,"didSafetyError"),q=new f.C1(y,"didReloadComposer"),L=new f.C1(y,"didLoadingError"),Y=new f.C1(y,"didWorkingDirectoryChange"),Z=new f.C1(y,"didIndexChange"),J=new f.C1(y,"didCancelGenerateCommits"),K=new f.C1(y,"didCancelGenerateCommitMessage"),X=new f.C1(y,"didErrorAIOperation"),ee=new f.C1(y,"didClearAIOperationError"),et=new f.C1(y,"didChangeAiEnabled"),eo=new f.C1(y,"didChangeAiModel");var ei=o(303),en=(e,t)=>(t=Symbol[e])?t:Symbol.for("Symbol."+e),es=e=>{throw TypeError(e)};function ea(e,t){return t.filter(t=>e.hunkIndices.includes(t.index))}function er(e){if(0===e.length)return{patch:"",filePatches:new Map};let t=new Map;for(let o of e){let e=o.diffHeader||`diff --git a/${o.fileName} b/${o.fileName}`,i=t.get(e);if(null==i&&(i=[],t.set(e,i)),o.isRename)i.push("");else{let e=`${o.hunkHeader}
${o.content}`;i.push(e)}}let o="";for(let[e,i]of t.entries()){o+=`${e.trim()}
`;let t=i.filter(e=>""!==e.trim());t.length>0&&(o+=`${t.join(`
`)}
`)}return{patch:o,filePatches:t}}function ec(e,t){return Math.max(0,Math.min(e.start+e.count,t.start+t.count)-Math.max(e.start,t.start))}function em(e,t){let o=[],i=0,n=[];if(e){let t=(0,ei.Tc)(e);({hunks:n,count:i}=ed(t,"staged",i)),o.push(...n)}if(t){let e=(0,ei.Tc)(t);({hunks:n,count:i}=ed(e,"unstaged",i)),o.push(...n)}return o}function ed(e,t,o,i,n){let s=[],a=o;for(let o of e.files)if(o.hunks.length)for(let e of o.hunks){let r=++a,{additions:c,deletions:m}=function(e){let t=e.split(`
`),o=0,i=0;for(let e of t)e.startsWith("+")&&!e.startsWith("+++")?o++:e.startsWith("-")&&!e.startsWith("---")&&i++;return{additions:o,deletions:i}}(e.content),d={index:r,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e.header,content:e.content,additions:c,deletions:m,source:t,assigned:!1,isRename:!1,author:i,coAuthors:n};s.push(d)}else{let e,r,c=++a;if(o.metadata.binary)e="binary",r="Binary file";else if(o.metadata.modeChanged)e="mode change",r=`Mode change from ${o.metadata.modeChanged.oldMode||"?"} to ${o.metadata.modeChanged.newMode||"?"}`;else if(o.metadata.renamedOrCopied){e="rename";let t=o.metadata.renamedOrCopied?.similarity||100;r=`Rename from ${o.originalPath}
Rename to ${o.path}
Similarity index ${t}%`}else e="no-content-change",r=o.header.split(`
`).slice(1).join(`
`);let m={index:c,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e,content:r,additions:0,deletions:0,source:t,assigned:!1,isRename:!1!==o.metadata.renamedOrCopied,author:i,coAuthors:n};s.push(m)}return{hunks:s,count:a}}async function eh(e,t,o){if(t){let o=await ef(e,t.baseSha,t.headSha);return{staged:void 0,unstaged:void 0,commits:o,unified:o}}if(o?.includeUntracked){let t=await e.git.status?.getUntrackedFiles();if(t?.length){var i=[];try{let o=((e,t,o)=>{if(null!=t){var i,n;"object"!=typeof t&&"function"!=typeof t&&es("Object expected"),o&&(i=t[en("asyncDispose")]),void 0===i&&(i=t[en("dispose")],o&&(n=i)),"function"!=typeof i&&es("Object not disposable"),n&&(i=function(){try{n.call(this)}catch(e){return Promise.reject(e)}}),e.push([o,i,t])}else o&&e.push([o]);return t})(i,await e.git.staging?.createTemporaryIndex("current"),!0);await e.git.staging?.stageFiles(t.map(e=>e.path),{intentToAdd:!0,index:o});let[n,s,r]=await Promise.allSettled([e.git.diff.getDiff?.(a.id,void 0,{index:o}),e.git.diff.getDiff?.(a.SU,void 0,{index:o}),e.git.diff.getDiff?.(a.SU,"HEAD",{notation:"...",index:o})]);return{staged:(0,u.Ro)(n),unstaged:(0,u.Ro)(s),unified:(0,u.Ro)(r),commits:void 0}}catch(e){var n=e,s=!0}finally{var r,c,m,d,h,l=(r=n,c=s,m="function"==typeof SuppressedError?SuppressedError:function(e,t,o,i){return(i=Error(o)).name="SuppressedError",i.error=e,i.suppressed=t,i},d=e=>r=c?new m(e,r,"An error was suppressed during disposal"):(c=!0,e),(h=e=>{for(;e=i.pop();)try{var t=e[1]&&e[1].call(e[2]);if(e[0])return Promise.resolve(t).then(h,e=>(d(e),h()))}catch(e){d(e)}if(c)throw r})());l&&await l}}}let[g,p,f]=await Promise.allSettled([e.git.diff.getDiff?.(a.id),e.git.diff.getDiff?.(a.SU),e.git.diff.getDiff?.(a.SU,"HEAD",{notation:"..."})]);return{staged:(0,u.Ro)(g),unstaged:(0,u.Ro)(p),unified:(0,u.Ro)(f),commits:void 0}}async function el(e,t,o,i,s){return{repoPath:e.path,headSha:i??null,baseSha:o??null,branchName:s,hashes:{staged:t.staged?.contents?await (0,n.sc)(t.staged.contents):null,unstaged:t.unstaged?.contents?await (0,n.sc)(t.unstaged.contents):null,unified:t.unified?.contents?await (0,n.sc)(t.unified.contents):null,commits:t.commits?.contents?await (0,n.sc)(t.commits.contents):null}}}async function eu(e,t,o,i){let s=[];try{if(e.path!==t.repoPath&&s.push(`Repository path changed from "${t.repoPath}" to "${e.path}"`),t.branchName){let o=await e.git.branches.getBranch(t.branchName);o?.sha!==t.headSha&&s.push(`HEAD commit changed from "${t.headSha}" to "${o?.sha}"`)}else{let o=await e.git.commits.getCommit("HEAD"),i=o?.sha??null;i!==t.baseSha&&s.push(`HEAD commit changed from "${t.baseSha}" to "${i}"`)}if(o?.length)if(t.hashes.commits){if(null===t.baseSha)return{isValid:!1,errors:["Base commit is null"]};if(null===t.headSha)return{isValid:!1,errors:["Head commit is null"]};let o=await ef(e,t.baseSha,t.headSha);if(!o?.contents)return{isValid:!1,errors:["Failed to calculate combined diff"]};await (0,n.sc)(o.contents)!==t.hashes.commits&&s.push("Branch changes have been modified since composer opened")}else{let{staged:a,unstaged:r}=i??await eh(e)??{staged:void 0,unstaged:void 0,unified:void 0},c={staged:a?.contents?await (0,n.sc)(a.contents):null,unstaged:r?.contents?await (0,n.sc)(r.contents):null};o.some(e=>"staged"===e.source)&&c.staged!==t.hashes.staged&&s.push("Staged changes have been modified since composer opened"),o.some(e=>"unstaged"===e.source)&&c.unstaged!==t.hashes.unstaged&&s.push("Unstaged changes have been modified since composer opened")}return{isValid:!s.length,errors:s}}catch(e){return s.push(`Failed to validate repository state: ${e instanceof Error?e.message:"Unknown error"}`),{isValid:!1,errors:s}}}async function eg(e,t,o,i){try{let e,n=await t.git.branches.getBranch(o);if(!n||(i&&(e=await t.git.branches.getBranch(i)),!e))return;let s=await t.git.refs.getMergeBase(n.ref,e.ref);if(!s)return;let a=await t.git.commits.getCommit(s);if(!a)return;let r=await t.git.commits.getLog(`${e.ref}..${n.ref}`,{limit:0});if(!r?.commits?.size)return;let c=Array.from(r.commits.values()).reverse(),m=c[c.length-1];return{commits:c,baseCommit:{sha:a.sha,message:a.message??""},headCommitSha:m?.sha??n.sha}}catch{return}}async function ep(e,t){try{let o=await e.git.config.getCurrentUser(),i=[],n=[],s=0;for(let a of t){let t=e.git.diff;if(!t?.getDiff)continue;let r=await t.getDiff(a.sha,`${a.sha}~1`);if(!r?.contents)continue;let c=(0,ei.Tc)(r.contents),m=[],d={...a.author,name:"You"===a.author.name?o?.name??a.author.name:a.author.name},{hunks:h,count:l}=ed(c,"commits",s,d,function(e){let t,o=[];if(!e.message)return o;let i=/^Co-authored-by:\s*(.+?)(?:\s*<(.+?)>)?\s*$/gm;for(;null!==(t=i.exec(e.message));){let[,i,n]=t;i&&o.push({name:i.trim(),email:n?.trim(),date:e.date})}return o}(a));n.push(...h),s=l,m.push(...h.map(e=>e.index));let u={id:a.sha,message:{content:a.message||"",isGenerated:!1},sha:a.sha,hunkIndices:m};i.push(u)}return{commits:i,hunks:n}}catch{return}}async function ef(e,t,o){try{let i=e.git.diff;if(!i?.getDiff)return;let n=await i.getDiff(o,t);if(!n?.contents)return;return n}catch{return}}var eC=Object.defineProperty,ex=Object.getOwnPropertyDescriptor,ew=(e,t,o,i)=>{for(var n,s=i>1?void 0:i?ex(t,o):t,a=e.length-1;a>=0;a--)(n=e[a])&&(s=(i?n(t,o,s):n(s))||s);return i&&s&&eC(t,o,s),s};let ComposerWebviewProvider=class ComposerWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=i.Disposable.from(h.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,l.wt)(this.onContextChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this)),this._context={...w},this._safetyState={repoPath:"",headSha:null,baseSha:null,hashes:{staged:null,unstaged:null,unified:null}}}_disposable;_args;_cache=new g.od({accessTTL:3e5});_generateCommitsCancellation;_generateCommitMessageCancellation;_repositorySubscription;_currentRepository;_hunks=[];_safetyState;_recompose=null;_context;_ignoreIndexChange=!1;_generateCommitsConversations=new Map;dispose(){this._cache.clear(),this.resetContext(),this._generateCommitsCancellation?.dispose(),this._generateCommitMessageCancellation?.dispose(),this._repositorySubscription?.dispose(),this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.session.start":this._context.sessionStart,"context.session.duration":this._context.sessionDuration,"context.source":"object"==typeof this._context.source?this._context.source.source:this._context.source,"context.mode":this._context.mode,"context.diff.files.count":this._context.diff.files,"context.diff.hunks.count":this._context.diff.hunks,"context.diff.lines.count":this._context.diff.lines,"context.diff.staged.exists":this._context.diff.staged,"context.diff.unstaged.exists":this._context.diff.unstaged,"context.diff.unstaged.included":this._context.diff.unstagedIncluded,"context.commits.initialCount":this._context.commits.initialCount,"context.commits.autoComposedCount":this._context.commits.autoComposedCount,"context.commits.composedCount":this._context.commits.composedCount,"context.commits.finalCount":this._context.commits.finalCount,"context.ai.enabled.config":this._context.ai.enabled.config,"context.ai.enabled.org":this._context.ai.enabled.org,"context.ai.model.id":this._context.ai.model?.id,"context.ai.model.name":this._context.ai.model?.name,"context.ai.model.provider.id":this._context.ai.model?.provider.id,"context.ai.model.temperature":this._context.ai.model?.temperature??void 0,"context.ai.model.maxTokens.input":this._context.ai.model?.maxTokens.input,"context.ai.model.maxTokens.output":this._context.ai.model?.maxTokens.output,"context.ai.model.default":this._context.ai.model?.default,"context.ai.model.hidden":this._context.ai.model?.hidden,"context.onboarding.stepReached":this._context.onboarding.stepReached,"context.onboarding.dismissed":this._context.onboarding.dismissed,"context.operations.generateCommits.count":this._context.operations.generateCommits.count,"context.operations.generateCommits.cancelled.count":this._context.operations.generateCommits.cancelledCount,"context.operations.generateCommits.error.count":this._context.operations.generateCommits.errorCount,"context.operations.generateCommits.feedback.upvote.count":this._context.operations.generateCommits.feedback.upvoteCount,"context.operations.generateCommits.feedback.downvote.count":this._context.operations.generateCommits.feedback.downvoteCount,"context.operations.generateCommitMessage.count":this._context.operations.generateCommitMessage.count,"context.operations.generateCommitMessage.cancelled.count":this._context.operations.generateCommitMessage.cancelledCount,"context.operations.generateCommitMessage.error.count":this._context.operations.generateCommitMessage.errorCount,"context.operations.finishAndCommit.error.count":this._context.operations.finishAndCommit.errorCount,"context.operations.undo.count":this._context.operations.undo.count,"context.operations.redo.count":this._context.operations.redo.count,"context.operations.reset.count":this._context.operations.reset.count,"context.warnings.workingDirectoryChanged":this._context.warnings.workingDirectoryChanged,"context.warnings.indexChanged":this._context.warnings.indexChanged,"context.errors.safety.count":this._context.errors.safety.count,"context.errors.operation.count":this._context.errors.operation.count}}includeBootstrap(e){return this._cache.getOrCreate("bootstrap",()=>this.getBootstrapState())}async getBootstrapState(){let e;this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let t=this._args;return null==(e=t?.repoPath!=null?this.container.git.getRepository(t.repoPath):this.container.git.getBestRepositoryOrFirst())?{...this.initialState,loadingError:"No repository found. Please open a Git repository to use the Commit Composer."}:t?.range?this.initializeStateAndContextFromExplicitRange(e,t.branchName,t.range,t.mode,t.source,t.commitShas):t?.branchName?this.initializeStateAndContextFromBranch(e,t.branchName,t.mode,t.source,t.commitShas):this.initializeStateAndContextFromWorkingDirectory(e,t?.includedUnstagedChanges,t?.mode,t?.source)}get initialState(){return{...this.host.baseWebviewState,...x}}async initializeStateAndContext(e,t,o,i,n,s,a,r="preview",c,m,d){this._generateCommitsConversations.clear(),this._currentRepository=e,this._hunks=t;let h=await el(e,i,n?.sha,s,a);if(this._safetyState=h,(a||n&&s)&&(this._recompose={enabled:!0,branchName:a,locked:!0,commitShas:m}),m&&m.length>0){let e=new Set(m);for(let t of o)t.sha&&!e.has(t.sha)&&(t.locked=!0)}let l=this.getAiEnabled(),u=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId}),g=this.isOnboardingDismissed(),p=this.getOnboardingStepReached();return this._context.diff.files=new Set(t.map(e=>e.fileName)).size,this._context.diff.hunks=t.length,this._context.diff.lines=t.reduce((e,t)=>e+t.content.split(`
`).length-1,0),this._context.commits.initialCount=0,this._context.ai.enabled.org=l.org,this._context.ai.enabled.config=l.config,this._context.ai.model=u,this._context.onboarding.dismissed=g,this._context.onboarding.stepReached=p,this._context.source="string"==typeof c?{source:c}:c,this._context.mode=r,this._context.warnings.workingDirectoryChanged=!1,this._context.warnings.indexChanged=!1,this._context.sessionStart=new Date().toISOString(),this.host.sendTelemetryEvent(d?"composer/reloaded":"composer/loaded",{}),{...this.initialState,hunks:t,baseCommit:n??null,commits:o,aiEnabled:l,ai:{model:u},hasChanges:o.length>0,mode:r,onboardingDismissed:g,workingDirectoryHasChanged:!1,indexHasChanged:!1,repositoryState:this.getRepositoryState(),recompose:this._recompose??null,autoComposeInstructions:this._args?.autoComposeInstructions}}async initializeStateAndContextFromWorkingDirectory(e,t,o="preview",i,n){let[s,a,r]=await Promise.allSettled([eh(e,void 0,{includeUntracked:!0}),e.git.commits.getCommit("HEAD"),e.git.branches.getBranch()]),c=(0,u.Ro)(s);this._context.diff.unstagedIncluded=!1,t&&(this._context.diff.unstagedIncluded=!0);let m=this._context.diff.unstagedIncluded?c?.unified:c?.staged,d=this._context.diff.unstagedIncluded?void 0:c?.unstaged;!c?.staged?.contents&&c?.unstaged?.contents&&(this._context.diff.unstagedIncluded=!0);let h=!!(m?.contents||d?.contents),l=em(m?.contents,d?.contents),g=(0,u.Ro)(a),p=(0,u.Ro)(r),f=!!m?.contents,C=!!d?.contents,x={id:"draft-commit-1",message:{content:"",isGenerated:!1},aiExplanation:"",hunkIndices:f&&C?l.filter(e=>"staged"===e.source).map(e=>e.index):l.map(e=>e.index)};return this._context.diff.staged=f,this._context.diff.unstaged=C,this._context.diff.commits=!1,this.subscribeToRepository(e),this.initializeStateAndContext(e,l,h?[x]:[],c,g?{sha:g.sha,message:g.message??"",repoName:e.name,branchName:p?.name??"main"}:void 0,void 0,void 0,o,i,void 0,n)}async initializeStateAndContextFromBranch(e,t,o="preview",i,n,s){let a,c=await e.git.branches.getBranch(t);if(!c)return{...this.initialState,loadingError:`Branch '${t}' not found.`};let m=t,d=c,h=new Set,l=0;for(;l<10&&(l++,!h.has(m));){h.add(m);let c=await (0,r.DY)(this.container,d);if(!c.paused&&c.value){a=c.value;let r=await eg(this.container,e,t,a);if(r&&r.commits.length>0){let{commits:a,baseCommit:c,headCommitSha:d}=r,h=await ep(e,a);if(!h)return{...this.initialState,loadingError:`Failed to process commits for branch '${t}'.`};let{commits:l,hunks:u}=h;if(n){let e=[...new Set(n)].filter(e=>!l.find(t=>t.sha===e));if(e.length>0)return{...this.initialState,loadingError:`The following commit shas were not found in the commits for branch '${t}': ${e.join(", ")}`}}let g=await eh(e,{baseSha:c.sha,headSha:d});return this.initializeStateAndContext(e,u,l,g,{sha:c.sha,message:c.message,repoName:e.name,branchName:t},d,m,o,i,n,s)}let h=await e.git.branches.getBranch(a);if(!h||h.name===m)break;m=h.name,d=h}else break}if(n?.length){let a=c.sha,r=(await e.git.commits.getCommit(n[0]))?.parents[0];if(a&&r)return this.initializeStateAndContextFromExplicitRange(e,t,{base:r,head:a},o,i,n,s)}return{...this.initialState,loadingError:`Could not identify unique commits for branch '${t}'`}}async initializeStateAndContextFromExplicitRange(e,t,o,i="preview",n,s,a){let{base:r,head:c}=o,m=await e.git.commits.getCommit(r);if(!m)return{...this.initialState,loadingError:`Base commit '${r}' not found.`};if(!await e.git.commits.getCommit(c))return{...this.initialState,loadingError:`Head commit '${c}' not found.`};let d=await e.git.commits.getLog(`${r}..${c}`,{limit:0});if(!d?.commits?.size)return{...this.initialState,loadingError:"No commits found between base commit and head commit."};let h=Array.from(d.commits.values()).reverse(),l=await ep(e,h);if(!l)return{...this.initialState,loadingError:t?`Failed to process commits for branch '${t}'.`:"Failed to process commits in range."};let{commits:u,hunks:g}=l;if(s&&s.length>0){let e=[...new Set(s)].filter(e=>!u.find(t=>t.sha===e));if(e.length>0)return{...this.initialState,loadingError:t?`The following commit shas were not found in the commits for branch '${t}': ${e.join(", ")}`:`The following commit shas were not found in the commits: ${e.join(", ")}`}}let p=await eh(e,{baseSha:r,headSha:c}),f={sha:r,message:m.message??"",repoName:e.name,branchName:t},C=await this.initializeStateAndContext(e,g,u,p,f,c,t,i,n,s,a);return this._recompose&&(this._recompose.range=o),C}getRepositoryState(){if(null==this._currentRepository)return;let{id:e,name:t,path:o,uri:i,virtual:n}=this._currentRepository;return{current:{id:e,name:t,path:o,uri:i.toString(),virtual:n},hasMultipleRepositories:this.container.git.openRepositoryCount>1}}async onAddHunksToCommit(e){"unstaged"===e.source&&(this._context.diff.unstagedIncluded=!0,this.host.sendTelemetryEvent("composer/action/includedUnstagedChanges"),await this.onReloadComposer({repoPath:this._currentRepository.path,mode:this._context.mode}))}onUndo(){this._context.operations.undo.count++,this.host.sendTelemetryEvent("composer/action/undo")}onRedo(){this._context.operations.redo.count++}onReset(){this._context.operations.reset.count++,this._generateCommitsConversations.clear(),this.host.sendTelemetryEvent("composer/action/reset")}async onChooseRepository(){let{title:e,placeholder:t}=(0,m.Nt)(this.container.git.openRepositories,"Switch",this._currentRepository?.name),o=await (0,m.oe)(this.container,e,t,this.container.git.openRepositories,{picked:this._currentRepository});null!=o&&await this.onReloadComposer({repoPath:o.path,source:"composer"})}async onReloadComposer(e){try{let t;this._cache.clear(),this._generateCommitsConversations.clear();let o=this._currentRepository;if((!o||null!=e.repoPath&&o?.path!==e.repoPath)&&!(o=null==e.repoPath?this.container.git.getBestRepositoryOrFirst():this.container.git.getRepository(e.repoPath))){this._context.errors.safety.count++;let e="Repository is no longer available";this.host.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}if((t=this._recompose?.range?await this.initializeStateAndContextFromExplicitRange(o,this._recompose.branchName,this._recompose.range,e.mode,this._context.source,this._recompose.commitShas,!0):this._recompose?.branchName?await this.initializeStateAndContextFromBranch(o,this._recompose.branchName,e.mode,this._context.source,this._recompose.commitShas,!0):await this.initializeStateAndContextFromWorkingDirectory(o,this._context.diff.unstagedIncluded,e.mode,this._context.source,!0)).loadingError)return void await this.host.notify(L,{error:t.loadingError});await this.host.notify(q,{hunks:t.hunks,commits:t.commits,baseCommit:t.baseCommit,loadingError:t.loadingError,hasChanges:t.hasChanges,repositoryState:t.repositoryState})}catch(e){this.host.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(L,{error:e instanceof Error?e.message:"Failed to reload composer"})}}async onCancelGenerateCommits(){this._generateCommitsCancellation&&(this._generateCommitsCancellation.cancel(),await this.host.notify(J,void 0))}async onCancelGenerateCommitMessage(){this._generateCommitMessageCancellation&&(this._generateCommitMessageCancellation.cancel(),await this.host.notify(K,void 0))}async onClearAIOperationError(){await this.host.notify(ee,void 0)}onOpenOnboarding(){this.advanceOnboardingStep(1)}onAdvanceOnboarding(e){this.advanceOnboardingStep(e.stepNumber)}advanceOnboardingStep(e){if(this.isOnboardingDismissed())return;let t=Math.max(this.container.storage.get("composer:onboarding:stepReached")??1,e);this._context.onboarding.stepReached=t,this.container.storage.store("composer:onboarding:stepReached",t).catch()}onDismissOnboarding(){this.isOnboardingDismissed()||(this._context.onboarding.dismissed=!0,this.container.storage.store("composer:onboarding:dismissed",C).catch())}isOnboardingDismissed(){return this.container.storage.get("composer:onboarding:dismissed")===C}getOnboardingStepReached(){return this.container.storage.get("composer:onboarding:stepReached")}resetContext(){this._context={...w}}onShowing(e,t,...o){return o?.[0]&&(this._cache.clear(),this.resetContext(),this._args=o[0],this.updateTitle(o[0].mode)),[!0,void 0]}updateTitle(e){"experimental"===(e??this._args?.mode??"preview")?this.host.title="Commit Composer (Experimental)":this.host.title="Commit Composer (Preview)"}async onClose(){this._context.sessionDuration=Date.now()-new Date(this._context.sessionStart).getTime(),await i.commands.executeCommand("workbench.action.closeActiveEditor")}async updateAiModel(){try{let e=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});this._context.ai.model=e,this.host.sendTelemetryEvent("composer/action/changeAiModel"),await this.host.notify(eo,{model:e})}catch{}}async onSelectAIModel(){await i.commands.executeCommand("gitlens.ai.switchProvider",{source:"composer",correlationId:this.host.instanceId,detail:"model-picker"})}async onAIFeedbackHelpful(e){this._context.operations.generateCommits.feedback.upvoteCount++,await this.sendComposerAIFeedback("helpful",e.sessionId)}async onAIFeedbackUnhelpful(e){this._context.operations.generateCommits.feedback.downvoteCount++,await this.sendComposerAIFeedback("unhelpful",e.sessionId)}async sendComposerAIFeedback(e,t){try{let o,i=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});if(!i)return;let n={id:t||"composer-session",type:"generate-commits",feature:"composer",model:{id:i.id,name:i.name,maxTokens:i.maxTokens,provider:{id:i.provider.id,name:i.provider.name},default:i.default,hidden:i.hidden,temperature:i.temperature},usage:void 0};if("unhelpful"===e&&(o=await (0,c.E)(),void 0===o))return;(0,c._)(this.container,{source:"composer",correlationId:this.host.instanceId},n,e,o)}catch{}}subscribeToRepository(e){this._repositorySubscription?.dispose(),this._repositorySubscription=i.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(this.onRepositoryFileSystemChanged,this),e.onDidChange(this.onRepositoryChanged,this))}async onRepositoryChanged(e){if(e.repository.id!==this._currentRepository?.id)return;let t=this._ignoreIndexChange;this._ignoreIndexChange=!1,!e.changed(s.Z_.Index,s.Ti.Any)||t&&e.changed(s.Z_.Index,s.Ti.Exclusive)||(this._context.warnings.indexChanged=!0,await this.host.notify(Z,void 0))}async onRepositoryFileSystemChanged(e){e.repository.id===this._currentRepository?.id&&(this._context.warnings.workingDirectoryChanged=!0,await this.host.notify(Y,void 0))}async onGenerateCommits(e){let t={"customInstructions.used":!1,"customInstructions.length":0,"customInstructions.hash":"","customInstructions.setting.used":!1,"customInstructions.setting.length":0,"customInstructions.commitMessage.setting.used":!1,"customInstructions.commitMessage.setting.length":0};try{let o=h.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.commitMessage.setting.used"]=!0,t["customInstructions.commitMessage.setting.length"]=o.length);let s=h.H.get("ai.generateCommits.customInstructions");s&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=s.length),this._context.operations.generateCommits.count++,e.customInstructions&&(t["customInstructions.used"]=!0,t["customInstructions.length"]=e.customInstructions.length,t["customInstructions.hash"]=(0,n.Fx)(e.customInstructions)),this._generateCommitsCancellation=new i.CancellationTokenSource,await this.host.notify(z,void 0);let a=[];if(this._recompose?.enabled&&this._safetyState?.hashes.commits){let t=e.commitsToReplace?.baseShaForNewDiff??this._safetyState.baseSha,o=this._safetyState.headSha;if(e.commitsToReplace?.commits?.length&&(o=e.commitsToReplace.commits[e.commitsToReplace.commits.length-1].sha??this._safetyState.headSha),e.commitsToReplace?.commits?.length&&e.commitsToReplace.commits.every(e=>!e.sha))for(let t of new Set(e.commitsToReplace.commits.flatMap(e=>e.hunkIndices)))a.push({...this._hunks.find(e=>e.index===t),assigned:!0});else{let i=await ef(this._currentRepository,t,o);for(let e of em(i.contents)){let{author:t,coAuthors:o}=function(e,t){let o,i=e.filter(e=>null!=e.author&&e.fileName===t.fileName&&(!t.isRename||e.isRename===t.isRename)),n=new Map,s=new Map,a=0;for(let e of i){s.set(e.author.name,e.author),e.coAuthors?.forEach(e=>s.set(e.name,e));let i=function(e,t){let o=e.hunkHeader.match(/@@ -(\d+),(\d+)/),i=e.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/),n=t.hunkHeader.match(/@@ -(\d+),(\d+)/),s=t.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/);return null==o||null==i||null==n||null==s?0:ec({start:parseInt(o[1],10),count:parseInt(o[2],10)},{start:parseInt(n[1],10),count:parseInt(n[2],10)})+ec({start:parseInt(i[1],10),count:parseInt(i[2],10)},{start:parseInt(s[1],10),count:parseInt(s[2],10)})}(e,t);n.has(e.author.name)&&(i+=n.get(e.author.name)),n.set(e.author.name,i),(null==o||i>a)&&(a=i,o=e.author)}return null!=o&&s.delete(o.name),{author:o,coAuthors:[...s.values()]}}(this._hunks,e);e.author=t,e.coAuthors=o.length?o:void 0,a.push({...e,assigned:!0})}if(e.commitsToReplace){let t=new Set(e.commitsToReplace.commits.flatMap(e=>e.hunkIndices));this._hunks=this._hunks.filter(e=>!t.has(e.index));let o=1;this._hunks.forEach(e=>{e.index=o++}),a.forEach(e=>{e.index=o++}),this._hunks.push(...a)}else this._hunks=a}}else for(let t of e.hunkIndices)a.push({...this._hunks.find(e=>e.index===t),assigned:!0});let r=e.commits.map(e=>({id:e.id,message:e.message.content,aiExplanation:e.aiExplanation,hunkIndices:e.hunkIndices})),c=await (0,n.sc)(a.map(e=>`${e.index}:${e.hunkHeader}:${e.content}`).join(`
`)),m=this._generateCommitsConversations.get(c);this.container.usage.track("action:gitlens.ai.generateCommits:happened").catch();let d=await this.container.ai.actions.generateCommits(a,r,a.map(e=>({index:e.index,hunkHeader:e.hunkHeader})),{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitsCancellation.token,customInstructions:e.customInstructions,conversation:m});if(this._generateCommitsCancellation?.token.isCancellationRequested){this._context.operations.generateCommits.cancelledCount++,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(J,void 0);return}if(d&&"cancelled"!==d){if(0===d.commits.length){this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"no commits generated"}),await this.host.notify(X,{operation:"generate commits",error:"No commits generated"});return}this._generateCommitsConversations.set(c,d.conversation);let o=d.commits.map((e,t)=>({id:`ai-commit-${t}`,message:{content:e.message,isGenerated:!0},aiExplanation:e.explanation,hunkIndices:e.hunks.map(e=>e.hunk)}));this._context.commits.autoComposedCount=o.length,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose":"composer/action/compose",t),this._recompose?.enabled&&(this._recompose.locked=!1),await this.host.notify(B,{commits:o,hunks:this._recompose?.enabled?this._hunks:void 0,replacedCommitIds:e.commitsToReplace?.commits.map(e=>e.id)})}else"cancelled"===d?(this._context.operations.generateCommits.cancelledCount++,await this.host.notify(J,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(X,{operation:"generate commits",error:void 0}))}catch(o){this._generateCommitsCancellation?.token.isCancellationRequested?(this._context.operations.generateCommits.cancelledCount++,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(J,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":o instanceof Error?o.message:"unknown error"}),await this.host.notify(X,{operation:"generate commits",error:o instanceof Error?o.message:void 0}))}finally{this._generateCommitsCancellation?.dispose(),this._generateCommitsCancellation=void 0}}async onGenerateCommitMessage(e){let t={"customInstructions.setting.used":!1,"customInstructions.setting.length":0,overwriteExistingMessage:e.overwriteExistingMessage??!1};try{let o=h.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommitMessage.count++,this._generateCommitMessageCancellation=new i.CancellationTokenSource,await this.host.notify(U,{commitId:e.commitId});let{patch:n}=er(this._hunks.filter(t=>e.commitHunkIndices.includes(t.index)));n||(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"Failed to create diff for commit"}),await this.host.notify(X,{operation:"generate commit message",error:"Failed to create diff for commit"}));let s=await this.container.ai.actions.generateCommitMessage(n,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitMessageCancellation.token});if(this._generateCommitMessageCancellation?.token.isCancellationRequested){this._context.operations.generateCommitMessage.cancelledCount++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(K,void 0);return}if(s&&"cancelled"!==s){let o=s.result.body?`${s.result.summary}

${s.result.body}`:s.result.summary;this.host.sendTelemetryEvent("composer/action/generateCommitMessage",t),await this.host.notify(G,{commitId:e.commitId,message:o})}else"cancelled"===s?(this._context.operations.generateCommitMessage.cancelledCount++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(K,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(X,{operation:"generate commit message",error:void 0}))}catch(e){this._generateCommitMessageCancellation?.token.isCancellationRequested?(this._context.operations.generateCommitMessage.cancelledCount++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(K,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.host.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(X,{operation:"generate commit message",error:e instanceof Error?e.message:void 0}))}finally{this._generateCommitMessageCancellation?.dispose(),this._generateCommitMessageCancellation=void 0}}async onFinishAndCommit(e){try{var t;let o,s,r,c;await this.host.notify(Q,void 0);let m=this.container.git.getRepository(this._safetyState.repoPath);if(!m){await this.host.notify(j,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++;let e="Repository is no longer available";this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let d=e.commits.flatMap(e=>e.hunkIndices),h=[];for(let e of d)h.push({...this._hunks.find(t=>t.index===e),assigned:!0});let l=h.filter(t=>e.commits.some(e=>e.hunkIndices.includes(t.index)));if(this._context.diff.unstagedIncluded){this._repositorySubscription?.dispose();let e=(await m.git.status?.getUntrackedFiles())?.map(e=>e.path);if(e?.length)try{o=await eh(m),await m.git.staging?.stageFiles(e)}catch{}}let u=await eu(m,this._safetyState,l,o);if(!u.isValid){await this.host.notify(j,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=u.errors.join(`
`);this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let g=(t=e.commits,t.map(e=>{let{patch:t,filePatches:o}=er(ea(e,h)),{author:i,coAuthors:n}=function(e){let t,o=new Map,i=new Map;for(let t of e)null!=t.author&&(i.set(t.author.name,t.author),t.coAuthors?.forEach(e=>i.set(e.name,e)),o.set(t.author.name,(o.get(t.author.name)??0)+t.additions+t.deletions));let n=0;for(let[e,s]of o.entries())(null==t||s>n)&&(t=i.get(e),n=s);return null!=t&&i.delete(t.name),{author:t,coAuthors:[...i.values()]}}(ea(e,h)),s=e.message.content;return n.length>0&&(s+=`
${n.map(e=>`
Co-authored-by: ${e.name} <${e.email}>`).join()}`),{message:s,explanation:e.aiExplanation,filePatches:o,patch:t,author:i}})),p=this.container.git.getRepositoryService(m.path);if(!p){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="No repository service found";throw this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(e.baseCommit?.sha==null){let e=await p.patch?.createEmptyInitialCommit();if(null==e){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Could not create base commit";throw this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}}let f=await m.git.config.getSigningConfig?.(),C=f?.enabled??!1,x=await m.git.patch?.createUnreachableCommitsFromPatches(e.baseCommit?.sha,g,{sign:C,source:{source:"composer"}});if(!x?.length){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to create commits from patches";throw this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let w=e.baseCommit?.sha??(await m.git.commits.getCommit("HEAD")?"HEAD":a.BI),y=(await m.git.diff.getDiff?.(x[x.length-1],w,{notation:e.baseCommit?.sha?"...":void 0}))?.contents;if(!y){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to get combined diff";throw this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(!function(e,t,o){let{hashes:i}=e;return i.commits?t===i.commits:t===(o?i.unified:i.staged)}(this._safetyState,await (0,n.sc)(y),this._context.diff.unstagedIncluded)){await this.host.notify(j,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Output diff does not match input";this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(V,{error:e});return}let _=!1;if(await m.git.status.hasWorkingChanges({throwOnError:!0})){if(r=await p.stash?.getStash(),r?.stashes.size){let e=r.stashes.values().next().value;e&&(s=e)}let e=`Commit composer: ${new Date().toLocaleString()}`;await p.stash?.saveStash(e,void 0,{includeUntracked:!0}),r=await p.stash?.getStash(),r?.stashes.size&&(c=r.stashes.values().next().value)&&c.ref!==s?.ref&&c.message?.includes(e)&&(_=!0)}this._recompose?.enabled&&this._recompose.branchName?await m.git.refs.updateReference(`refs/heads/${this._recompose.branchName}`,x[x.length-1]):await p.ops?.reset(x[x.length-1],{mode:"hard"}),c&&_&&await p.stash?.applyStash(c.stashName,{deleteAfter:!0}),this._context.commits.finalCount=x.length,this.host.sendTelemetryEvent("composer/action/finishAndCommit"),await this.host.notify(j,void 0),i.commands.executeCommand("workbench.action.closeActiveEditor")}catch(t){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=t instanceof Error?t.message:"unknown error";this.host.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(j,void 0),i.window.showErrorMessage(`Failed to commit changes: ${e}`)}}onAnyConfigurationChanged(e){if(h.H.changed(e,"ai.enabled")){let e=this.container.ai.enabled;this._context.ai.enabled.config=e,this.host.notify(et,{config:e})}}onContextChanged(e){if("gitlens:gk:organization:ai:enabled"===e){let e=this.container.ai.allowed;this._context.ai.enabled.org=e,this.host.notify(et,{org:e})}}onAIModelChanged(e){this.updateAiModel()}getAiEnabled(){return{org:this.container.ai.allowed,config:this.container.ai.enabled}}_panelWasVisible;_isMaximized=!1;async maximize(){if(this._isMaximized)this._panelWasVisible&&await (0,d.S4)("workbench.action.togglePanel"),this._isMaximized=!1,this._panelWasVisible=void 0;else{try{await (0,d.S4)("workbench.action.focusPanel"),this._panelWasVisible=!0,await (0,d.S4)("workbench.action.togglePanel")}catch{this._panelWasVisible=!1}this._isMaximized=!0}}};ew([(0,p.a1)(O)],ComposerWebviewProvider.prototype,"onAddHunksToCommit",1),ew([(0,p.a1)(H)],ComposerWebviewProvider.prototype,"onUndo",1),ew([(0,p.a1)(W)],ComposerWebviewProvider.prototype,"onRedo",1),ew([(0,p.a1)(N)],ComposerWebviewProvider.prototype,"onReset",1),ew([(0,p.a1)($)],ComposerWebviewProvider.prototype,"onChooseRepository",1),ew([(0,p.a1)(k)],ComposerWebviewProvider.prototype,"onReloadComposer",1),ew([(0,p.a1)(E)],ComposerWebviewProvider.prototype,"onCancelGenerateCommits",1),ew([(0,p.a1)(I)],ComposerWebviewProvider.prototype,"onCancelGenerateCommitMessage",1),ew([(0,p.a1)(R)],ComposerWebviewProvider.prototype,"onClearAIOperationError",1),ew([(0,p.a1)(D)],ComposerWebviewProvider.prototype,"onOpenOnboarding",1),ew([(0,p.a1)(F)],ComposerWebviewProvider.prototype,"onAdvanceOnboarding",1),ew([(0,p.a1)(P)],ComposerWebviewProvider.prototype,"onDismissOnboarding",1),ew([(0,p.a1)(S)],ComposerWebviewProvider.prototype,"onClose",1),ew([(0,p.a1)(A)],ComposerWebviewProvider.prototype,"onSelectAIModel",1),ew([(0,p.a1)(M)],ComposerWebviewProvider.prototype,"onAIFeedbackHelpful",1),ew([(0,p.a1)(T)],ComposerWebviewProvider.prototype,"onAIFeedbackUnhelpful",1),ew([(0,p.a1)(_)],ComposerWebviewProvider.prototype,"onGenerateCommits",1),ew([(0,p.a1)(v)],ComposerWebviewProvider.prototype,"onGenerateCommitMessage",1),ew([(0,p.a1)(b)],ComposerWebviewProvider.prototype,"onFinishAndCommit",1)}};